<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pudge Wars - Warcraft 3 Original</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #0a0a0a; font-family: 'Segoe UI', sans-serif; }
    canvas { display: block; position: fixed; top: 0; left: 0; z-index: 1; }
    
    #ui { position: fixed; top: 10px; left: 10px; color: #fff; z-index: 100; pointer-events: none; }
    #ui h1 { font-size: 28px; color: #e74c3c; text-shadow: 0 0 15px rgba(231,76,60,0.6); }
    #connectionStatus { font-size: 14px; color: #888; }

    #stats { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.85); border: 2px solid #e74c3c; border-radius: 8px; padding: 12px 16px; color: #fff; z-index: 100; min-width: 220px; pointer-events: auto; }
    #stats h3 { color: #e74c3c; margin-bottom: 8px; font-size: 14px; text-transform: uppercase; }
    .stat-row { display: flex; justify-content: space-between; margin: 4px 0; font-size: 12px; }
    .stat-label { color: #aaa; }
    .stat-value { color: #e74c3c; font-weight: bold; }

    #attributes { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); border: 2px solid #f39c12; border-radius: 8px; padding: 10px 20px; color: #fff; z-index: 100; display: flex; gap: 20px; pointer-events: none; }
    .attr { text-align: center; }
    .attr-icon { font-size: 22px; display: block; }
    .attr-value { color: #f39c12; font-weight: bold; font-size: 16px; }
    .attr-label { font-size: 10px; color: #888; text-transform: uppercase; }

    #bars { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); width: 500px; z-index: 100; pointer-events: none; }
    .bar-container { background: rgba(0,0,0,0.8); border: 2px solid #333; border-radius: 4px; margin: 3px 0; overflow: hidden; position: relative; }
    .bar { height: 25px; transition: width 0.1s; }
    #healthBar { background: linear-gradient(90deg, #c0392b, #e74c3c); width: 100%; }
    #manaBar { background: linear-gradient(90deg, #2980b9, #3498db); width: 100%; }
    .bar-text { position: absolute; color: #fff; font-size: 12px; font-weight: bold; text-shadow: 1px 1px 2px #000; top: 50%; left: 50%; transform: translate(-50%, -50%); }

    #abilities { position: fixed; bottom: 20px; right: 20px; display: flex; gap: 12px; z-index: 100; }
    .ability { width: 70px; height: 70px; background: rgba(0,0,0,0.85); border: 3px solid #e74c3c; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; position: relative; transition: all 0.2s; }
    .ability:hover { transform: scale(1.08); border-color: #f39c12; box-shadow: 0 0 20px rgba(243,156,18,0.5); }
    .ability.on-cooldown { opacity: 0.6; cursor: not-allowed; border-color: #666; }
    .ability-icon { font-size: 32px; }
    .ability-key { position: absolute; top: 3px; left: 6px; font-size: 11px; color: #fff; background: rgba(0,0,0,0.8); padding: 2px 5px; border-radius: 4px; font-weight: bold; }
    .ability-cd { position: absolute; bottom: 3px; font-size: 10px; color: #fff; background: rgba(0,0,0,0.9); padding: 2px 6px; border-radius: 4px; font-weight: bold; }
    .ability-level { position: absolute; top: 3px; right: 6px; font-size: 10px; color: #f39c12; background: rgba(0,0,0,0.8); padding: 2px 5px; border-radius: 4px; }

    #ultimate { position: fixed; bottom: 20px; right: 200px; width: 90px; height: 90px; background: rgba(0,0,0,0.85); border: 3px solid #9b59b6; border-radius: 12px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; position: relative; transition: all 0.2s; z-index: 100; }
    #ultimate:hover { transform: scale(1.1); border-color: #8e44ad; box-shadow: 0 0 30px rgba(142,68,173,0.6); }
    #ultimate.on-cooldown { opacity: 0.6; cursor: not-allowed; border-color: #666; }
    #ultimate .ability-icon { font-size: 40px; }
    #ultimate .ability-key { top: 4px; left: 8px; font-size: 12px; }
    #ultimate .ability-cd { bottom: 4px; font-size: 11px; }
    #ultimate .ability-level { top: 4px; right: 8px; font-size: 10px; color: #f39c12; }

    #startScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
    #startScreen.hidden { display: none; }
    #startScreen h1 { font-size: 64px; color: #e74c3c; margin-bottom: 10px; text-shadow: 0 0 40px rgba(231,76,60,0.8); }
    #startScreen p { color: #aaa; margin-bottom: 30px; font-size: 18px; }
    #startBtn { padding: 18px 60px; font-size: 22px; font-weight: bold; color: #fff; background: linear-gradient(135deg, #e74c3c, #c0392b); border: none; border-radius: 10px; cursor: pointer; text-transform: uppercase; box-shadow: 0 0 30px rgba(231,76,60,0.5); }
    #startBtn:hover { transform: scale(1.05); box-shadow: 0 0 50px rgba(231,76,60,0.8); }

    #controls { position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 12px; border-radius: 8px; color: #888; font-size: 11px; z-index: 100; pointer-events: none; }
    #controls kbd { background: #333; padding: 3px 8px; border-radius: 4px; color: #fff; margin: 0 2px; font-weight: bold; }

    #notification { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 56px; font-weight: bold; text-align: center; z-index: 2000; pointer-events: none; text-shadow: 0 0 40px rgba(0,0,0,0.8); animation: notifyPop 0.5s ease-out forwards; }
    @keyframes notifyPop { 0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 0; } }
    .notify-hit { color: #e74c3c; }
    .notify-kill { color: #f39c12; }
    .notify-save { color: #2ecc71; }

    #minimap { position: fixed; bottom: 10px; right: 10px; width: 180px; height: 180px; background: rgba(0,0,0,0.8); border: 2px solid #444; border-radius: 8px; z-index: 100; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <canvas id="minimap" width="180" height="180"></canvas>

  <div id="ui">
    <h1>ü•© PUDGE WARS <span style="font-size:14px;color:#888;">DOTA 2 ORIGINAL</span></h1>
    <p id="connectionStatus">Connecting...</p>
  </div>

  <div id="attributes">
    <div class="attr"><span class="attr-icon">üí™</span><span class="attr-value" id="str">0</span><span class="attr-label">STR</span></div>
    <div class="attr"><span class="attr-icon">üèπ</span><span class="attr-value" id="agi">0</span><span class="attr-label">AGI</span></div>
    <div class="attr"><span class="attr-icon">üß†</span><span class="attr-value" id="int">0</span><span class="attr-label">INT</span></div>
    <div class="attr"><span class="attr-icon">‚öîÔ∏è</span><span class="attr-value" id="damageAttr">0</span><span class="attr-label">DMG</span></div>
    <div class="attr"><span class="attr-icon">üõ°Ô∏è</span><span class="attr-value" id="armorAttr">0</span><span class="attr-label">ARMOR</span></div>
  </div>

  <div id="stats">
    <h3>ü•© PUDGE</h3>
    <div class="stat-row"><span class="stat-label">Level</span><span class="stat-value" id="level">1</span></div>
    <div class="stat-row"><span class="stat-label">üí∞ Gold</span><span class="stat-value" id="gold">0</span></div>
    <div class="stat-row"><span class="stat-label">üíÄ Kills</span><span class="stat-value" id="kills">0</span></div>
    <div class="stat-row"><span class="stat-label">‚ò†Ô∏è Deaths</span><span class="stat-value" id="deaths">0</span></div>
    <div class="stat-row"><span class="stat-label">ü™ù Flesh</span><span class="stat-value" id="fleshStacks">0</span></div>
    <div class="stat-row"><span class="stat-label">‚≠ê XP</span><span class="stat-value" id="xp">0</span></div>
  </div>

  <div id="shop" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);border:3px solid #f39c12;border-radius:12px;padding:20px;z-index:500;display:none;max-width:600px;max-height:500px;overflow-y:auto;">
    <h2 style="color:#f39c12;margin-bottom:15px;text-align:center;">üè™ BLACK MARKET</h2>
    <div id="shopItems" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;"></div>
    <button id="closeShop" style="position:absolute;top:10px;right:10px;background:#e74c3c;color:#fff;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-weight:bold;">‚úï</button>
  </div>

  <div id="perks" style="position:fixed;bottom:100px;left:20px;display:flex;flex-direction:column;gap:8px;z-index:100;"></div>

  <div id="bars">
    <div class="bar-container">
      <div id="healthBar" class="bar"></div>
      <span class="bar-text" id="healthText">700/700</span>
    </div>
    <div class="bar-container">
      <div id="manaBar" class="bar"></div>
      <span class="bar-text" id="manaText">291/291</span>
    </div>
  </div>

  <div id="abilities">
    <div class="ability" id="abilityQ">
      <span class="ability-key">Q</span>
      <span class="ability-icon">ü™ù</span>
      <span class="ability-cd" id="qCd"></span>
      <span class="ability-level" id="qLvl">1</span>
    </div>
    <div class="ability" id="abilityE">
      <span class="ability-key">E</span>
      <span class="ability-icon">‚ò†Ô∏è</span>
      <span class="ability-cd" id="eCd"></span>
      <span class="ability-level" id="eLvl">1</span>
    </div>
  </div>

  <div id="ultimate">
    <span class="ability-key">R</span>
    <span class="ability-icon">üíÄ</span>
    <span class="ability-cd" id="rCd"></span>
    <span class="ability-level" id="rLvl">0</span>
  </div>

  <div id="startScreen">
    <h1>ü•© PUDGE WARS</h1>
    <p>Dota 2 Original Mechanics</p>
    <p style="font-size:14px;color:#888;margin-bottom:20px;">Q: Hook (90/180/270/360) ‚Ä¢ E: Rot (30/40/50/60 + slow) ‚Ä¢ R: Dismember</p>
    <button id="startBtn">Start Battle</button>
  </div>

  <div id="controls">
    <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move &nbsp;|&nbsp; <kbd>Q</kbd> Meat Hook &nbsp;|&nbsp; <kbd>E</kbd> Rot &nbsp;|&nbsp; <kbd>R</kbd> Dismember &nbsp;|&nbsp; <kbd>P</kbd> Shop
  </div>

  <script src="progression.js"></script>
  <script defer>
// ============================================
// –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø - WARCRAFT 3 PUDGE WARS ORIGINAL
// ============================================
const CONFIG = {
  FIELD_SIZE: 2000, RIVER_Y: 1000, RIVER_WIDTH: 180,
  PLAYER_RADIUS: 24, PLAYER_SPEED: 3.56, // 285 MS
  BASE_HEALTH: 700, BASE_MANA: 267, BASE_DAMAGE: 52, BASE_ARMOR: 1,
  BASE_STR: 25, BASE_AGI: 14, BASE_INT: 14, // WC3 stats
  
  // Q - Meat Hook (Warcraft 3 Original)
  HOOK_RANGE: [1000, 1100, 1200, 1300],
  HOOK_SPEED: 25, // 1600 —é–Ω–∏—Ç–æ–≤/—Å–µ–∫
  HOOK_RADIUS: 12,
  HOOK_COOLDOWN: [14000, 13000, 12000, 11000],
  HOOK_DAMAGE: [100, 200, 300, 400], // WC3 –∫–ª–∞—Å—Å–∏–∫–∞
  HOOK_MANA_COST: [100, 100, 100, 100],
  HOOK_PULL_SPEED: 10,
  
  // E - Rot (Warcraft 3 Original)
  ROT_DAMAGE: [40, 80, 120, 160],
  ROT_RADIUS: 250,
  ROT_SLOW: [0.15, 0.20, 0.25, 0.30],
  
  // –ü–∞—Å—Å–∏–≤–∫–∞ - Flesh Heap
  FLESH_HEAP_RANGE: 450,
  FLESH_HEAP_STR_PER_STACK: [1.0, 1.5, 2.0, 2.5],
  FLESH_HEAP_MAGIC_RESIST: [0.10, 0.15, 0.20, 0.25],
  
  // R - Dismember (Warcraft 3 Original)
  DISMEMBER_DAMAGE: [80, 120, 160],
  DISMEMBER_DURATION: 2750, // 2.75 —Å–µ–∫
  DISMEMBER_COOLDOWN: [30000, 25000, 20000],
  DISMEMBER_MANA_COST: [100, 130, 170],
  DISMEMBER_RANGE: 200,
  DISMEMBER_HEAL: 1.0, // 100% —Ö–∏–ª
  DISMEMBER_STR_FACTOR: 0.5
};

// ============================================
// –°–û–°–¢–û–Ø–ù–ò–ï
// ============================================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let ws = null, myId = null, gameRunning = false;

const state = { players: new Map(), hooks: [], myTeam: null, myPlayer: null, matchStartTime: Date.now() };
const input = { keys: {}, mouseX: 0, mouseY: 0, hookRequested: false, rotRequested: false, dismemberRequested: false };
const cooldowns = { hook: 0, rot: 0, dismember: 0 };
const abilityLevels = { hook: 1, rot: 1, dismember: 0 };
const abilityPoints = { count: 0 };
const particles = [];

// ============================================
// –ó–í–£–ö–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê (Warcraft 3 Style)
// ============================================
let audioCtx = null;

function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}

function playSound(type) {
  if (!audioCtx || audioCtx.state === 'suspended') return;
  
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  
  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  
  const now = audioCtx.currentTime;
  
  switch(type) {
    case 'hook':
      oscillator.frequency.setValueAtTime(200, now);
      oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.3);
      gainNode.gain.setValueAtTime(0.3, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      oscillator.start(now);
      oscillator.stop(now + 0.3);
      break;
    case 'hit':
      oscillator.type = 'sawtooth';
      oscillator.frequency.setValueAtTime(150, now);
      oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.2);
      gainNode.gain.setValueAtTime(0.4, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      oscillator.start(now);
      oscillator.stop(now + 0.2);
      break;
    case 'rot':
      oscillator.type = 'sawtooth';
      oscillator.frequency.setValueAtTime(80, now);
      oscillator.frequency.linearRampToValueAtTime(60, now + 0.5);
      gainNode.gain.setValueAtTime(0.2, now);
      gainNode.gain.linearRampToValueAtTime(0.01, now + 0.5);
      oscillator.start(now);
      oscillator.stop(now + 0.5);
      break;
    case 'death':
      oscillator.type = 'triangle';
      oscillator.frequency.setValueAtTime(200, now);
      oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.5);
      gainNode.gain.setValueAtTime(0.3, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
      oscillator.start(now);
      oscillator.stop(now + 0.5);
      break;
    case 'kill':
      oscillator.type = 'square';
      oscillator.frequency.setValueAtTime(400, now);
      oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.3);
      gainNode.gain.setValueAtTime(0.2, now);
      gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
      oscillator.start(now);
      oscillator.stop(now + 0.3);
      break;
  }
}

// ============================================
// –ö–õ–ê–°–°–´
// ============================================
class Player {
  constructor(data) {
    this.id = data[0]; this.x = data[1]; this.y = data[2]; this.team = data[3];
    this.health = data[4]; this.maxHealth = data[5];
    this.mana = data[6]; this.maxMana = data[7];
    this.level = data[8]; this.str = data[9]; this.agi = data[10]; this.int = data[11];
    this.damage = data[12]; this.armor = data[13];
    this.kills = data[14]; this.deaths = data[15];
    this.fleshHeapStacks = data[16]; this.rotActive = data[17]; this.gold = data[18];
    this.hookLevel = data[19] || 1; this.rotLevel = data[20] || 1; this.dismemberLevel = data[21] || 0;
    this.angle = 0; this.isDead = false; this.dismembered = false;
    this.name = data[24] || `Pudge_${this.id}`;
  }
  update() { if (this.id === myId) this.angle = Math.atan2(input.mouseY - canvas.height/2, input.mouseX - canvas.width/2); }
  draw(ctx, cameraX, cameraY) {
    const sx = this.x - cameraX, sy = this.y - cameraY;
    
    // –°–≤–µ—á–µ–Ω–∏–µ —Å–≤–æ–µ–≥–æ –∏–≥—Ä–æ–∫–∞
    if (this.id === myId) {
      const g = ctx.createRadialGradient(sx, sy, 0, sx, sy, CONFIG.PLAYER_RADIUS * 3);
      g.addColorStop(0, 'rgba(241, 196, 15, 0.4)');
      g.addColorStop(1, 'rgba(241, 196, 15, 0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(sx, sy, CONFIG.PLAYER_RADIUS * 3, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Rot –∞—É—Ä–∞ - –∑–µ–ª—ë–Ω–æ–µ –±–æ–ª–æ—Ç–Ω–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ (Warcraft 3 style)
    if (this.rotActive) {
      const rg = ctx.createRadialGradient(sx, sy, 0, sx, sy, CONFIG.ROT_RADIUS);
      rg.addColorStop(0, 'rgba(50, 205, 50, 0.4)');
      rg.addColorStop(0.4, 'rgba(34, 139, 34, 0.25)');
      rg.addColorStop(0.7, 'rgba(0, 100, 0, 0.15)');
      rg.addColorStop(1, 'rgba(0, 50, 0, 0)');
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(sx, sy, CONFIG.ROT_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      
      // –ß–∞—Å—Ç–∏—Ü—ã Rot
      if (Math.random() < 0.3) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * CONFIG.ROT_RADIUS;
        particles.push(new Particle(
          this.x + Math.cos(angle) * dist,
          this.y + Math.sin(angle) * dist,
          'rgba(50, 205, 50, 0.6)',
          2,
          20
        ));
      }
    }
    
    // –¢–µ–ª–æ –∏–≥—Ä–æ–∫–∞ - –≤ —Å—Ç–∏–ª–µ WC3
    ctx.beginPath();
    ctx.arc(sx, sy, CONFIG.PLAYER_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = this.team === 'radiant' ? '#27ae60' : '#c0392b';
    ctx.fill();
    
    // –û–±–≤–æ–¥–∫–∞
    ctx.lineWidth = 4;
    ctx.strokeStyle = this.id === myId ? '#f1c40f' : '#1a1a1a';
    ctx.stroke();
    
    // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫—Ä—É–≥ (–¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è)
    ctx.beginPath();
    ctx.arc(sx, sy, CONFIG.PLAYER_RADIUS * 0.7, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∑–≥–ª—è–¥–∞ (–∫–æ–ø—å—ë/—Ä—É–∫–∞)
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(
      sx + Math.cos(this.angle) * CONFIG.PLAYER_RADIUS * 1.8,
      sy + Math.sin(this.angle) * CONFIG.PLAYER_RADIUS * 1.8
    );
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.stroke();
    
    // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä "YOU"
    if (this.id === myId) {
      ctx.fillStyle = '#f1c40f';
      ctx.font = 'bold 13px Arial';
      ctx.textAlign = 'center';
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 4;
      ctx.fillText('YOU', sx, sy - CONFIG.PLAYER_RADIUS - 12);
      ctx.shadowBlur = 0;
    }
    
    // –ü–æ–ª–æ—Å–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è (WC3 style)
    const hpWidth = 50;
    const hpHeight = 6;
    const hpPercent = this.health / this.maxHealth;
    
    // –§–æ–Ω
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(sx - hpWidth/2, sy + CONFIG.PLAYER_RADIUS + 6, hpWidth, hpHeight);
    
    // –ó–¥–æ—Ä–æ–≤—å–µ
    let hpColor;
    if (hpPercent > 0.6) hpColor = '#27ae60';
    else if (hpPercent > 0.3) hpColor = '#f39c12';
    else hpColor = '#c0392b';
    
    ctx.fillStyle = hpColor;
    ctx.fillRect(sx - hpWidth/2 + 1, sy + CONFIG.PLAYER_RADIUS + 7, (hpWidth - 2) * hpPercent, hpHeight - 2);
    
    // –†–∞–º–∫–∞ –ø–æ–ª–æ—Å–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.strokeRect(sx - hpWidth/2, sy + CONFIG.PLAYER_RADIUS + 6, hpWidth, hpHeight);
  }
}

class Hook {
  constructor(data) {
    this.id = data[0]; this.x = data[1]; this.y = data[2];
    this.targetX = data[3]; this.targetY = data[4]; this.ownerId = data[5];
    this.state = data[6] || 'flying'; this.targetId = null; this.trail = [];
    const dx = this.targetX - this.x, dy = this.targetY - this.y;
    const dist = Math.hypot(dx, dy);
    this.vx = (dx / dist) * CONFIG.HOOK_SPEED; this.vy = (dy / dist) * CONFIG.HOOK_SPEED;
    this.traveled = 0;
  }
  update() {
    if (this.state === 'flying') {
      this.trail.push({ x: this.x, y: this.y, life: 15 });
      this.x += this.vx; this.y += this.vy; this.traveled += CONFIG.HOOK_SPEED;
      if (this.traveled >= CONFIG.HOOK_RANGE[abilityLevels.hook - 1]) this.state = 'returning';
    } else if (this.state === 'returning' || this.state === 'pulling') {
      const owner = state.players.get(this.ownerId);
      if (owner) {
        const dx = owner.x - this.x, dy = owner.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 15) { this.state = 'done'; }
        else {
          this.x += (dx / dist) * CONFIG.HOOK_PULL_SPEED; this.y += (dy / dist) * CONFIG.HOOK_PULL_SPEED;
          if (this.state === 'pulling' && this.targetId !== null) {
            const target = state.players.get(this.targetId);
            if (target) { target.x = this.x; target.y = this.y; }
          }
        }
      } else { this.state = 'done'; }
    }
    for (let i = this.trail.length - 1; i >= 0; i--) { this.trail[i].life--; if (this.trail[i].life <= 0) this.trail.splice(i, 1); }
  }
  draw(ctx, cameraX, cameraY) {
    const sx = this.x - cameraX, sy = this.y - cameraY;
    const owner = state.players.get(this.ownerId); if (!owner) return;
    const ox = owner.x - cameraX, oy = owner.y - cameraY;
    
    // –°–ª–µ–¥ –∫—Ä—é–∫–∞ - –∫–∞–ø–ª–∏ –∫—Ä–æ–≤–∏ (Warcraft 3 style)
    for (const point of this.trail) {
      const alpha = point.life / 15;
      ctx.globalAlpha = alpha;
      
      // –ö—Ä–æ–≤—è–Ω—ã–µ –∫–∞–ø–ª–∏
      const trailSize = CONFIG.HOOK_RADIUS * (0.5 + point.life / 30);
      ctx.fillStyle = '#8b0000';
      ctx.beginPath();
      ctx.arc(point.x - cameraX, point.y - cameraY, trailSize, 0, Math.PI * 2);
      ctx.fill();
      
      // –ë–ª–µ—Å–∫
      ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
      ctx.beginPath();
      ctx.arc(point.x - cameraX - 2, point.y - cameraY - 2, trailSize * 0.5, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    
    // –¶–µ–ø—å –∫—Ä—é–∫–∞
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(sx, sy);
    ctx.strokeStyle = '#4a4a4a';
    ctx.lineWidth = 5;
    ctx.setLineDash([8, 5]);
    ctx.lineCap = 'round';
    ctx.stroke();
    ctx.setLineDash([]);
    
    // –í—Ç–æ—Ä–∞—è —Ü–µ–ø—å (–¥–ª—è –æ–±—ä—ë–º–∞)
    ctx.beginPath();
    ctx.moveTo(ox + 3, oy + 3);
    ctx.lineTo(sx + 3, sy + 3);
    ctx.strokeStyle = '#2a2a2a';
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 5]);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // –ö—Ä—é–∫
    ctx.beginPath();
    ctx.arc(sx, sy, CONFIG.HOOK_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = this.state === 'pulling' ? '#ff4500' : '#8b0000';
    ctx.fill();
    
    // –û–±–≤–æ–¥–∫–∞ –∫—Ä—é–∫–∞
    ctx.strokeStyle = '#ff6347';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // –ë–ª–µ—Å–∫ –Ω–∞ –∫—Ä—é–∫–µ
    ctx.beginPath();
    ctx.arc(sx - 4, sy - 4, CONFIG.HOOK_RADIUS * 0.4, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.fill();
    
    // –û—Å—Ç—Ä–∏—ë –∫—Ä—é–∫–∞
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(
      sx + Math.cos(Math.atan2(this.vy, this.vx)) * CONFIG.HOOK_RADIUS * 1.5,
      sy + Math.sin(Math.atan2(this.vy, this.vx)) * CONFIG.HOOK_RADIUS * 1.5
    );
    ctx.strokeStyle = '#ff4500';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.stroke();
  }
}

class Particle {
  constructor(x, y, color, speed, life) {
    this.x = x; this.y = y; this.color = color;
    this.angle = Math.random() * Math.PI * 2;
    this.speed = speed * (0.5 + Math.random() * 0.5);
    this.vx = Math.cos(this.angle) * this.speed;
    this.vy = Math.sin(this.angle) * this.speed;
    this.life = life; this.maxLife = life;
    this.size = 4 + Math.random() * 4;
  }
  update() { this.x += this.vx; this.y += this.vy; this.vx *= 0.96; this.vy *= 0.96; this.life--; }
  draw(ctx, cameraX, cameraY) {
    const alpha = this.life / this.maxLife; ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color; ctx.beginPath();
    ctx.arc(this.x - cameraX, this.y - cameraY, this.size, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  }
}

function createHitEffect(x, y, color) { for (let i = 0; i < 20; i++) particles.push(new Particle(x, y, color, 6, 35)); }
function createDeathEffect(x, y) { for (let i = 0; i < 40; i++) { particles.push(new Particle(x, y, '#8e44ad', 10, 60)); particles.push(new Particle(x, y, '#e74c3c', 8, 50)); } }
function createHookHitEffect(x, y) { for (let i = 0; i < 25; i++) { particles.push(new Particle(x, y, '#e74c3c', 8, 40)); particles.push(new Particle(x, y, '#f39c12', 6, 30)); } }

// ============================================
// –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
// ============================================
document.addEventListener('DOMContentLoaded', () => {
  console.log('[DEBUG] DOMContentLoaded');
  
  function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
  window.addEventListener('resize', resize); resize();

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –∫–Ω–æ–ø–∫–∏
  const startBtn = document.getElementById('startBtn');
  console.log('[DEBUG] startBtn element:', startBtn);
  
  if (!startBtn) {
    console.error('[ERROR] startBtn not found!');
  } else {
    startBtn.addEventListener('click', () => {
      console.log('[DEBUG] Start button clicked');
      initAudio(); // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–≤—É–∫–∞
      document.getElementById('startScreen').classList.add('hidden');
      gameRunning = true;
      console.log('[DEBUG] Connecting to server...');
      connect();
    });
  }

  // –£–ü–†–ê–í–õ–ï–ù–ò–ï
  document.addEventListener('keydown', (e) => {
    console.log('[DEBUG] Key down:', e.code, 'gameRunning:', gameRunning);
    input.keys[e.code] = true;
    if (e.code === 'KeyQ' && gameRunning) input.hookRequested = true;
    if (e.code === 'KeyE' && gameRunning) input.rotRequested = true;
    if (e.code === 'KeyR' && gameRunning) input.dismemberRequested = true;
  });

  document.addEventListener('keyup', (e) => { input.keys[e.code] = false; });
  document.addEventListener('mousemove', (e) => { input.mouseX = e.clientX; input.mouseY = e.clientY; });
  document.addEventListener('mousedown', (e) => { if (e.button === 0 && gameRunning) input.hookRequested = true; });

  document.getElementById('abilityQ').addEventListener('click', () => { if (gameRunning) input.hookRequested = true; });
  document.getElementById('abilityE').addEventListener('click', () => { if (gameRunning) input.rotRequested = true; });
  document.getElementById('ultimate').addEventListener('click', () => { if (gameRunning) input.dismemberRequested = true; });

  // –ó–∞–ø—É—Å–∫ –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
  console.log('[DEBUG] Starting game loop');
  gameLoop();
});

// ============================================
// –°–ï–¢–¨
// ============================================
function connect() {
  const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
  const wsUrl = `${protocol}//${location.host}`;
  console.log('[DEBUG] Connecting to WebSocket:', wsUrl);
  ws = new WebSocket(wsUrl);
  ws.onopen = () => {
    console.log('[DEBUG] WebSocket connected');
    document.getElementById('connectionStatus').textContent = 'Connected ‚úì';
    document.getElementById('connectionStatus').style.color = '#2ecc71';
  };
  ws.onmessage = (e) => handleServerMessage(JSON.parse(e.data));
  ws.onclose = () => {
    console.log('[DEBUG] WebSocket closed');
    document.getElementById('connectionStatus').textContent = 'Disconnected ‚úó';
    document.getElementById('connectionStatus').style.color = '#e74c3c';
    gameRunning = false;
  };
  ws.onerror = (err) => {
    console.error('[DEBUG] WebSocket error:', err);
    document.getElementById('connectionStatus').textContent = 'Connection Error';
    document.getElementById('connectionStatus').style.color = '#e74c3c';
  };
}

function handleServerMessage(data) {
  console.log('[DEBUG] Received message:', data.type);
  switch(data.type) {
    case 'welcome':
      console.log('[DEBUG] Welcome! Player ID:', data.playerId, 'Team:', data.team);
      myId = data.playerId; myTeam = data.team; state.myTeam = data.team;
      for (const p of data.players) state.players.set(p[0], new Player(p));
      break;
    case 'state':
      const newPlayers = new Map();
      for (const p of data.players) {
        const existing = state.players.get(p[0]);
        if (existing) {
          Object.assign(existing, {
            x: p[1], y: p[2], team: p[3], health: p[4], maxHealth: p[5],
            mana: p[6], maxMana: p[7], level: p[8], str: p[9], agi: p[10],
            int: p[11], damage: p[12], armor: p[13], kills: p[14], deaths: p[15],
            fleshHeapStacks: p[16], rotActive: p[17], gold: p[18],
            hookLevel: p[19], rotLevel: p[20], dismemberLevel: p[21]
          });
          newPlayers.set(p[0], existing);
        } else { newPlayers.set(p[0], new Player(p)); }
      }
      state.players = newPlayers;
      state.hooks = data.hooks.map(h => new Hook(h));
      if (data.stats && myId) {
        const myStats = data.stats.find(s => s[0] === myId);
        if (myStats) { state.myPlayer = newPlayers.get(myId); abilityPoints.count = myStats[6] || 0; }
      }
      if (data.matchStartTime) state.matchStartTime = data.matchStartTime;
      break;
    case 'event': handleEvent(data.event); break;
  }
}

function handleEvent(evt) {
  if (evt.type === 'hookFire' && evt.playerId === myId) {
    startCooldown('hook');
    createHookHitEffect(state.players.get(myId)?.x || 0, state.players.get(myId)?.y || 0, '#e74c3c');
    playSound('hook');
  }
  if (evt.type === 'hookHit') {
    const target = state.players.get(evt.targetId);
    if (target) {
      createHitEffect(target.x, target.y, '#e74c3c');
      playSound('hit');
      if (target.id === myId) showNotification('HOOKED!', 'notify-hit');
    }
  }
  if (evt.type === 'rotToggle') {
    const p = state.players.get(evt.playerId);
    if (p) {
      p.rotActive = evt.active;
      if (evt.active) playSound('rot');
      if (evt.playerId === myId) startCooldown('rot');
    }
  }
  if (evt.type === 'playerKill') {
    const victim = state.players.get(evt.victimId);
    if (victim) {
      createDeathEffect(victim.x, victim.y);
      playSound('death');
      if (evt.killerId === myId) {
        playSound('kill');
        showNotification('KILL! +150üí∞', 'notify-kill');
      }
    }
  }
  if (evt.type === 'allySaved') showNotification('SAVE!', 'notify-save');
}

function sendInput() {
  if (!ws || ws.readyState !== WebSocket.OPEN || !gameRunning) return;
  let dx = 0, dy = 0;
  if (input.keys['KeyW']) dy -= 1;
  if (input.keys['KeyS']) dy += 1;
  if (input.keys['KeyA']) dx -= 1;
  if (input.keys['KeyD']) dx += 1;
  if (dx !== 0 || dy !== 0) { const len = Math.hypot(dx, dy); dx /= len; dy /= len; ws.send(JSON.stringify({ type: 'move', dx, dy })); }
  if (input.hookRequested) { const angle = Math.atan2(input.mouseY - canvas.height/2, input.mouseX - canvas.width/2); ws.send(JSON.stringify({ type: 'hook', angle, abilityLevel: abilityLevels.hook })); input.hookRequested = false; }
  if (input.rotRequested) { ws.send(JSON.stringify({ type: 'rot', abilityLevel: abilityLevels.rot })); input.rotRequested = false; }
  if (input.dismemberRequested) { const angle = Math.atan2(input.mouseY - canvas.height/2, input.mouseX - canvas.width/2); ws.send(JSON.stringify({ type: 'dismember', angle, abilityLevel: abilityLevels.dismember })); input.dismemberRequested = false; }
}

// ============================================
// UI
// ============================================
function startCooldown(ability) {
  const now = Date.now();
  if (ability === 'hook') cooldowns.hook = now + CONFIG.HOOK_COOLDOWN[abilityLevels.hook - 1];
  if (ability === 'rot') cooldowns.rot = now + 1000;
  if (ability === 'dismember') cooldowns.dismember = now + CONFIG.DISMEMBER_COOLDOWN[abilityLevels.dismember - 1];
}

function updateCooldowns() {
  const now = Date.now();
  const hookEl = document.getElementById('abilityQ'), hookCdEl = document.getElementById('qCd');
  if (cooldowns.hook > now) { hookEl.classList.add('on-cooldown'); hookCdEl.textContent = ((cooldowns.hook - now) / 1000).toFixed(1); }
  else { hookEl.classList.remove('on-cooldown'); hookCdEl.textContent = ''; }
  const rotEl = document.getElementById('abilityE');
  const ultiEl = document.getElementById('ultimate'), ultiCdEl = document.getElementById('rCd');
  if (cooldowns.dismember > now) { ultiEl.classList.add('on-cooldown'); ultiCdEl.textContent = ((cooldowns.dismember - now) / 1000).toFixed(1); }
  else { ultiEl.classList.remove('on-cooldown'); ultiCdEl.textContent = ''; }
}

function updateUI() {
  const player = state.players.get(myId); if (!player) return;
  const hpPercent = (player.health / player.maxHealth) * 100;
  const manaPercent = (player.mana / player.maxMana) * 100;
  document.getElementById('healthBar').style.width = hpPercent + '%';
  document.getElementById('manaBar').style.width = manaPercent + '%';
  document.getElementById('healthText').textContent = `${Math.round(player.health)}/${Math.round(player.maxHealth)}`;
  document.getElementById('manaText').textContent = `${Math.round(player.mana)}/${Math.round(player.maxMana)}`;
  document.getElementById('level').textContent = player.level;
  document.getElementById('kills').textContent = player.kills;
  document.getElementById('deaths').textContent = player.deaths;
  document.getElementById('fleshStacks').textContent = player.fleshHeapStacks || 0;
  document.getElementById('gold').textContent = Math.round(player.gold || 0);
  document.getElementById('str').textContent = Math.round(player.str);
  document.getElementById('agi').textContent = Math.round(player.agi);
  document.getElementById('int').textContent = Math.round(player.int);
  document.getElementById('damageAttr').textContent = Math.round(player.damage);
  document.getElementById('armorAttr').textContent = Math.round((player.armor || 1) * 100) / 100;
  document.getElementById('qLvl').textContent = player.hookLevel || 1;
  document.getElementById('eLvl').textContent = player.rotLevel || 1;
  document.getElementById('rLvl').textContent = player.dismemberLevel || 0;
  updateCooldowns();
}

function showNotification(text, type) {
  const el = document.createElement('div');
  el.className = 'notify-' + type; el.textContent = text;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 600);
}

// ============================================
// –ö–ê–ú–ï–†–ê –ò –†–ï–ù–î–ï–†–ò–ù–ì
// ============================================
function updateCamera() {
  const player = state.players.get(myId);
  if (!player) return { x: 0, y: 0 };
  return { x: player.x - canvas.width / 2, y: player.y - canvas.height / 2 };
}

// ============================================
// –û–¢–†–ò–°–û–í–ö–ê –ö–ê–†–¢–´ –í –°–¢–ò–õ–ï WARCRAFT 3
// ============================================
const mapFeatures = {
  trees: [],
  runes: [],
  creepSpawns: { radiant: [], dire: [] }
};

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–µ—Ä–µ–≤—å–µ–≤ –ø–æ –∫—Ä–∞—è–º –∫–∞—Ä—Ç—ã
function generateMapFeatures() {
  mapFeatures.trees = [];
  const treeSpacing = 80;
  const mapSize = CONFIG.FIELD_SIZE;
  const borderZone = 150;
  
  // –î–µ—Ä–µ–≤—å—è –ø–æ –ø–µ—Ä–∏–º–µ—Ç—Ä—É
  for (let x = borderZone; x < mapSize; x += treeSpacing) {
    // –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞
    if (Math.random() > 0.3) {
      mapFeatures.trees.push({
        x: x + Math.random() * 40 - 20,
        y: borderZone + Math.random() * 60,
        radius: 25 + Math.random() * 15,
        type: Math.random() > 0.5 ? 'pine' : 'oak'
      });
    }
    // –ù–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞
    if (Math.random() > 0.3) {
      mapFeatures.trees.push({
        x: x + Math.random() * 40 - 20,
        y: mapSize - borderZone - Math.random() * 60,
        radius: 25 + Math.random() * 15,
        type: Math.random() > 0.5 ? 'pine' : 'oak'
      });
    }
  }
  for (let y = borderZone; y < mapSize; y += treeSpacing) {
    // –õ–µ–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
    if (Math.random() > 0.3) {
      mapFeatures.trees.push({
        x: borderZone + Math.random() * 60,
        y: y + Math.random() * 40 - 20,
        radius: 25 + Math.random() * 15,
        type: Math.random() > 0.5 ? 'pine' : 'oak'
      });
    }
    // –ü—Ä–∞–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
    if (Math.random() > 0.3) {
      mapFeatures.trees.push({
        x: mapSize - borderZone - Math.random() * 60,
        y: y + Math.random() * 40 - 20,
        radius: 25 + Math.random() * 15,
        type: Math.random() > 0.5 ? 'pine' : 'oak'
      });
    }
  }
  
  // –†—É–Ω—ã (4 —Ç–æ—á–∫–∏ –Ω–∞ –∫–∞—Ä—Ç–µ)
  mapFeatures.runes = [
    { x: 400, y: 400, type: 'haste', active: true, respawnTime: 0 },
    { x: 1600, y: 400, type: 'regen', active: true, respawnTime: 0 },
    { x: 400, y: 1600, type: 'damage', active: true, respawnTime: 0 },
    { x: 1600, y: 1600, type: 'mana', active: true, respawnTime: 0 }
  ];
}

function drawMap(cameraX, cameraY) {
  // === –ó–ï–ú–õ–Ø –í –°–¢–ò–õ–ï WARCRAFT 3 - –¢–Å–ú–ù–û–ï –ë–û–õ–û–¢–û ===
  const groundGrad = ctx.createRadialGradient(
    canvas.width/2, canvas.height/2, 0,
    canvas.width/2, canvas.height/2, canvas.width
  );
  groundGrad.addColorStop(0, '#2d2a26');
  groundGrad.addColorStop(0.5, '#1f1c18');
  groundGrad.addColorStop(1, '#151210');
  ctx.fillStyle = groundGrad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // –¢–µ–∫—Å—Ç—É—Ä–∞ –∑–µ–º–ª–∏ - —à—É–º
  ctx.fillStyle = 'rgba(93, 64, 55, 0.1)';
  for (let i = 0; i < 100; i++) {
    const x = ((i * 137) % canvas.width);
    const y = ((i * 243) % canvas.height);
    const size = (i % 5) + 2;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }

  // === –†–ï–ö–ê - –ú–£–¢–ù–ê–Ø –ë–û–õ–û–¢–ù–ê–Ø –í–û–î–ê (Warcraft 3 Style) ===
  const riverScreenY = CONFIG.RIVER_Y - cameraY - CONFIG.RIVER_WIDTH / 2;
  
  // –û—Å–Ω–æ–≤–Ω–∞—è –≤–æ–¥–∞
  const riverGrad = ctx.createLinearGradient(0, riverScreenY, 0, riverScreenY + CONFIG.RIVER_WIDTH);
  riverGrad.addColorStop(0, 'rgba(45, 87, 67, 0.7)');
  riverGrad.addColorStop(0.3, 'rgba(52, 102, 79, 0.8)');
  riverGrad.addColorStop(0.5, 'rgba(58, 117, 89, 0.9)');
  riverGrad.addColorStop(0.7, 'rgba(52, 102, 79, 0.8)');
  riverGrad.addColorStop(1, 'rgba(45, 87, 67, 0.7)');
  ctx.fillStyle = riverGrad;
  ctx.fillRect(0, riverScreenY, canvas.width, CONFIG.RIVER_WIDTH);

  // –ì—Ä–∞–Ω–∏—Ü—ã —Ä–µ–∫–∏ (–±–µ—Ä–µ–≥–∞)
  ctx.strokeStyle = 'rgba(45, 38, 30, 0.8)';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(0, riverScreenY + 2);
  ctx.lineTo(canvas.width, riverScreenY + 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, riverScreenY + CONFIG.RIVER_WIDTH - 2);
  ctx.lineTo(canvas.width, riverScreenY + CONFIG.RIVER_WIDTH - 2);
  ctx.stroke();

  // –í–æ–ª–Ω—ã –Ω–∞ —Ä–µ–∫–µ (–∞–Ω–∏–º–∞—Ü–∏—è)
  const time = Date.now() / 1000;
  ctx.strokeStyle = 'rgba(100, 180, 140, 0.3)';
  ctx.lineWidth = 2;
  for (let i = 0; i < 8; i++) {
    const waveY = riverScreenY + (CONFIG.RIVER_WIDTH / 8) * i;
    ctx.beginPath();
    for (let x = 0; x < canvas.width; x += 40) {
      const waveX = x + Math.sin(time * 2 + i) * 15;
      const yOffset = Math.cos(time + x / 100) * 5;
      if (x === 0) ctx.moveTo(waveX, waveY + yOffset);
      else ctx.lineTo(waveX, waveY + yOffset);
    }
    ctx.stroke();
  }

  // === –°–ï–¢–ö–ê –í –°–¢–ò–õ–ï WC3 ===
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1;
  const gridSize = 100;
  const offsetX = -cameraX % gridSize;
  const offsetY = -cameraY % gridSize;
  for (let x = offsetX; x < canvas.width; x += gridSize) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
  }
  for (let y = offsetY; y < canvas.height; y += gridSize) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
  }

  // === –ì–†–ê–ù–ò–¶–´ –ö–ê–†–¢–´ ===
  ctx.strokeStyle = '#8b4513';
  ctx.lineWidth = 6;
  ctx.strokeRect(-cameraX, -cameraY, CONFIG.FIELD_SIZE, CONFIG.FIELD_SIZE);
  
  // –£–≥–ª–æ–≤—ã–µ –±–∞—à–Ω–∏
  const towerSize = 40;
  ctx.fillStyle = '#4a3a2a';
  const corners = [
    [-cameraX, -cameraY],
    [-cameraX + CONFIG.FIELD_SIZE - towerSize, -cameraY],
    [-cameraX, -cameraY + CONFIG.FIELD_SIZE - towerSize],
    [-cameraX + CONFIG.FIELD_SIZE - towerSize, -cameraY + CONFIG.FIELD_SIZE - towerSize]
  ];
  for (const [x, y] of corners) {
    ctx.fillRect(x, y, towerSize, towerSize);
    ctx.strokeStyle = '#6b5a4a';
    ctx.lineWidth = 3;
    ctx.strokeRect(x, y, towerSize, towerSize);
  }
}
      ctx.lineTo(x, waveY + Math.sin(x / 50 + Date.now() / 500) * 5);
    }
    ctx.stroke();
  }

  // –ú–æ—Å—Ç —á–µ—Ä–µ–∑ —Ä–µ–∫—É
  const bridgeX = CONFIG.FIELD_SIZE / 2 - cameraX - 100;
  const bridgeY = CONFIG.RIVER_Y - cameraY - 60;
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(bridgeX, bridgeY, 200, 120);
  ctx.strokeStyle = '#654321';
  ctx.lineWidth = 4;
  ctx.strokeRect(bridgeX, bridgeY, 200, 120);

  // –î–µ—Ä–µ–≤—å—è
  for (const tree of mapFeatures.trees) {
    const tx = tree.x - cameraX;
    const ty = tree.y - cameraY;
    
    // –¢–µ–Ω—å
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(tx + 10, ty + 10, tree.radius * 0.8, tree.radius * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // –°—Ç–≤–æ–ª
    ctx.fillStyle = '#654321';
    ctx.fillRect(tx - tree.radius * 0.2, ty - tree.radius * 0.5, tree.radius * 0.4, tree.radius);
    
    // –ö—Ä–æ–Ω–∞
    if (tree.type === 'pine') {
      // –ï–ª—å (—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∞—è)
      ctx.fillStyle = '#228B22';
      ctx.beginPath();
      ctx.moveTo(tx, ty - tree.radius * 1.5);
      ctx.lineTo(tx + tree.radius, ty);
      ctx.lineTo(tx - tree.radius, ty);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#2E8B2E';
      ctx.beginPath();
      ctx.moveTo(tx, ty - tree.radius);
      ctx.lineTo(tx + tree.radius * 0.8, ty + tree.radius * 0.5);
      ctx.lineTo(tx - tree.radius * 0.8, ty + tree.radius * 0.5);
      ctx.closePath();
      ctx.fill();
    } else {
      // –î—É–± (–∫—Ä—É–≥–ª–∞—è)
      ctx.fillStyle = '#228B22';
      ctx.beginPath();
      ctx.arc(tx, ty - tree.radius * 0.5, tree.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#2E8B2E';
      ctx.beginPath();
      ctx.arc(tx - tree.radius * 0.3, ty - tree.radius * 0.7, tree.radius * 0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(tx + tree.radius * 0.3, ty - tree.radius * 0.7, tree.radius * 0.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // –†—É–Ω—ã
  const now = Date.now();
  for (const rune of mapFeatures.runes) {
    if (now < rune.respawnTime) continue;
    const rx = rune.x - cameraX;
    const ry = rune.y - cameraY;
    
    // –°–≤–µ—á–µ–Ω–∏–µ
    const glowColor = rune.type === 'haste' ? '#00BFFF' : rune.type === 'regen' ? '#32CD32' : rune.type === 'damage' ? '#FF4500' : '#9370DB';
    const glow = ctx.createRadialGradient(rx, ry, 0, rx, ry, 30);
    glow.addColorStop(0, glowColor);
    glow.addColorStop(1, 'transparent');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(rx, ry, 30, 0, Math.PI * 2);
    ctx.fill();
    
    // –ò–∫–æ–Ω–∫–∞ —Ä—É–Ω—ã
    ctx.fillStyle = glowColor;
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const runeSymbol = rune.type === 'haste' ? '‚ö°' : rune.type === 'regen' ? '‚ù§Ô∏è' : rune.type === 'damage' ? '‚öîÔ∏è' : 'üíé';
    ctx.fillText(runeSymbol, rx, ry);
  }

  // –ì—Ä–∞–Ω–∏—Ü–∞ –∫–∞—Ä—Ç—ã
  ctx.strokeStyle = '#e74c3c';
  ctx.lineWidth = 4;
  ctx.strokeRect(-cameraX, -cameraY, CONFIG.FIELD_SIZE, CONFIG.FIELD_SIZE);
}

function drawMinimap() {
  const mm = document.getElementById('minimap'); const mmCtx = mm.getContext('2d');
  const SCALE = 180 / CONFIG.FIELD_SIZE;
  
  // –§–æ–Ω –º–∏–Ω–∏–∫–∞—Ä—Ç—ã
  mmCtx.fillStyle = 'rgba(20,20,30,0.95)';
  mmCtx.fillRect(0, 0, 180, 180);
  
  // –†–µ–∫–∞
  mmCtx.fillStyle = 'rgba(52,152,219,0.6)';
  mmCtx.fillRect(0, (CONFIG.RIVER_Y - CONFIG.RIVER_WIDTH/2) * SCALE, 180, CONFIG.RIVER_WIDTH * SCALE);
  
  // –ú–æ—Å—Ç
  mmCtx.fillStyle = '#8B4513';
  mmCtx.fillRect((CONFIG.FIELD_SIZE/2 - 100) * SCALE, (CONFIG.RIVER_Y - 60) * SCALE, 200 * SCALE, 120 * SCALE);
  
  // –î–µ—Ä–µ–≤—å—è –Ω–∞ –º–∏–Ω–∏–∫–∞—Ä—Ç–µ
  for (const tree of mapFeatures.trees) {
    mmCtx.fillStyle = 'rgba(34,139,34,0.6)';
    mmCtx.beginPath();
    mmCtx.arc(tree.x * SCALE, tree.y * SCALE, 2, 0, Math.PI * 2);
    mmCtx.fill();
  }
  
  // –ò–≥—Ä–æ–∫–∏
  for (const p of state.players.values()) {
    mmCtx.fillStyle = p.team === 'radiant' ? '#2ecc71' : '#e74c3c';
    const size = p.id === myId ? 6 : 4;
    mmCtx.beginPath(); mmCtx.arc(p.x * SCALE, p.y * SCALE, size, 0, Math.PI * 2); mmCtx.fill();
  }
  const player = state.players.get(myId);
  if (player) {
    mmCtx.strokeStyle = '#fff'; mmCtx.lineWidth = 1;
    mmCtx.strokeRect((player.x - canvas.width/2) * SCALE, (player.y - canvas.height/2) * SCALE, canvas.width * SCALE, canvas.height * SCALE);
  }
}

function updateAndDrawParticles(cameraX, cameraY) {
  for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.update(); p.draw(ctx, cameraX, cameraY); if (p.life <= 0) particles.splice(i, 1); }
  if (particles.length > 500) particles.splice(0, particles.length - 500);
}

function draw() {
  const camera = updateCamera();
  drawMap(camera.x, camera.y);
  updateAndDrawParticles(camera.x, camera.y);
  for (const hook of state.hooks) hook.draw(ctx, camera.x, camera.y);
  for (const player of state.players.values()) { player.update(); player.draw(ctx, camera.x, camera.y); }
  drawMinimap();
  updateUI();
}

// ============================================
// –ì–ï–ù–ï–†–ê–¶–ò–Ø –ö–ê–†–¢–´
// ============================================
function generateMapFeatures() {
  // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –æ–±—ä–µ–∫—Ç–æ–≤ –∫–∞—Ä—Ç—ã
}

// ============================================
// –ò–ì–†–û–í–û–ô –¶–ò–ö–õ
// ============================================
function gameLoop() {
  if (gameRunning) { sendInput(); draw(); }
  requestAnimationFrame(gameLoop);
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–∞–≥–∞–∑–∏–Ω–∞
if (typeof initShop === 'function') initShop();

requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
