<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pudge Wars - Hook Battle</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #1a1a2e; font-family: 'Segoe UI', sans-serif; }
    canvas { display: block; }

    #ui { position: fixed; top: 10px; left: 10px; color: #fff; z-index: 100; pointer-events: none; }
    #ui h1 { font-size: 24px; color: #e74c3c; text-shadow: 0 0 10px rgba(231,76,60,0.5); margin-bottom: 5px; }
    #ui p { font-size: 12px; color: #888; }

    #stats { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px 15px; border-radius: 8px; color: #fff; z-index: 100; }
    #stats div { margin: 3px 0; font-size: 13px; }
    .stat-label { color: #888; }
    .stat-value { color: #e74c3c; font-weight: bold; }

    #leaderboard { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); border: 2px solid #444; border-radius: 8px; padding: 10px 20px; z-index: 100; min-width: 300px; }
    #leaderboard h3 { color: #e74c3c; font-size: 12px; margin: 0 0 8px 0; text-align: center; text-transform: uppercase; }
    .lb-row { display: flex; justify-content: space-between; padding: 3px 0; font-size: 11px; }
    .lb-row.me { background: rgba(241, 196, 15, 0.2); padding: 3px 8px; margin: 0 -8px; border-radius: 4px; }
    .lb-name { color: #aaa; }
    .lb-kills { color: #e74c3c; }

    #hookIndicator { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 8px 20px; border-radius: 20px; color: #fff; font-size: 14px; z-index: 100; transition: all 0.2s; }
    #hookIndicator.ready { border: 2px solid #2ecc71; box-shadow: 0 0 10px rgba(46,204,113,0.5); }
    #hookIndicator.cooldown { border: 2px solid #e74c3c; opacity: 0.7; }
    #hookCooldownBar { position: fixed; bottom: 55px; left: 50%; transform: translateX(-50%); width: 150px; height: 6px; background: rgba(0,0,0,0.7); border-radius: 3px; overflow: hidden; z-index: 100; display: none; }
    #hookCooldownFill { height: 100%; background: linear-gradient(90deg, #e74c3c, #f39c12); width: 100%; transition: width 0.05s linear; }

    #matchTimer { position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); border: 2px solid #e74c3c; border-radius: 8px; padding: 8px 20px; color: #fff; font-size: 18px; font-weight: bold; z-index: 100; }
    #matchTimer.urgent { border-color: #f00; color: #f00; animation: timerPulse 0.5s infinite; }
    @keyframes timerPulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }

    #gameOverScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; }
    #gameOverScreen.show { display: flex; }
    #gameOverScreen h1 { font-size: 64px; margin-bottom: 20px; }
    #gameOverScreen.victory h1 { color: #2ecc71; text-shadow: 0 0 30px rgba(46,204,113,0.6); }
    #gameOverScreen.defeat h1 { color: #e74c3c; text-shadow: 0 0 30px rgba(231,76,60,0.6); }
    #gameOverScreen p { color: #aaa; font-size: 18px; margin-bottom: 30px; }
    #gameOverScreen .finalScore { font-size: 24px; color: #f1c40f; margin-bottom: 20px; }
    #restartBtn { padding: 15px 40px; font-size: 18px; font-weight: bold; color: #fff; background: linear-gradient(135deg, #e74c3c, #c0392b); border: none; border-radius: 8px; cursor: pointer; }
    #restartBtn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(231,76,60,0.5); }

    #upgrades { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); border: 2px solid #e74c3c; border-radius: 12px; padding: 10px 15px; z-index: 100; display: flex; gap: 10px; align-items: center; }
    #upgrades h3 { color: #e74c3c; font-size: 12px; margin: 0 10px 0 0; text-transform: uppercase; }
    .upgrade-item { background: rgba(40,20,20,0.8); border: 1px solid #633; border-radius: 6px; padding: 6px 10px; cursor: pointer; transition: all 0.2s; display: flex; flex-direction: column; align-items: center; min-width: 50px; }
    .upgrade-item:hover { background: rgba(60,30,30,0.9); border-color: #e74c3c; transform: translateY(-2px); }
    .upgrade-item.maxed { opacity: 0.5; cursor: default; border-color: #444; }
    .upg-icon { font-size: 16px; }
    .upg-name { color: #aaa; font-size: 9px; text-transform: uppercase; }
    .upg-level { color: #e74c3c; font-size: 14px; font-weight: bold; }

    .enemy-arrow { position: fixed; width: 0; height: 0; pointer-events: none; z-index: 90; }
    .enemy-arrow::after { content: ''; position: absolute; width: 20px; height: 20px; border: 3px solid #e74c3c; border-radius: 50%; border-left-color: transparent; border-top-color: transparent; transform: rotate(-45deg); }

    #notification { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 48px; font-weight: bold; text-align: center; z-index: 1000; pointer-events: none; text-shadow: 0 0 30px rgba(0,0,0,0.8); animation: notifyPop 0.5s ease-out forwards; }
    @keyframes notifyPop { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 0; } }
    .notify-hit { color: #e74c3c; }
    .notify-kill { color: #f39c12; }
    .notify-save { color: #2ecc71; }

    #minimap { position: fixed; top: 10px; right: 10px; width: 150px; height: 150px; background: rgba(0,0,0,0.8); border: 2px solid #444; border-radius: 8px; z-index: 100; }

    #soundToggle { position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); border: 2px solid #444; border-radius: 8px; padding: 8px 12px; color: #fff; cursor: pointer; z-index: 100; font-size: 18px; }
    #soundToggle:hover { border-color: #e74c3c; }

    #startScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
    #startScreen.hidden { display: none; }
    #startScreen h1 { font-size: 48px; color: #e74c3c; margin-bottom: 20px; text-shadow: 0 0 30px rgba(231,76,60,0.6); }
    #startScreen p { color: #aaa; margin-bottom: 30px; font-size: 14px; }
    #startScreen input { padding: 12px 20px; font-size: 16px; background: rgba(40,20,20,0.8); border: 2px solid #633; border-radius: 8px; color: #fff; margin-bottom: 15px; text-align: center; }
    #startScreen input:focus { outline: none; border-color: #e74c3c; }
    #startScreen input::placeholder { color: #644; }
    #startBtn { padding: 15px 40px; font-size: 18px; font-weight: bold; color: #fff; background: linear-gradient(135deg, #e74c3c, #c0392b); border: none; border-radius: 8px; cursor: pointer; text-transform: uppercase; }
    #startBtn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(231,76,60,0.5); }
    #startBtn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
    #loadingStatus { color: #888; font-size: 12px; margin-top: 15px; display: flex; align-items: center; gap: 8px; }
    #loadingStatus .spinner { width: 16px; height: 16px; border: 2px solid #444; border-top-color: #e74c3c; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    #loadingStatus.ready { color: #2ecc71; }
    #loadingStatus.error { color: #e74c3c; }

    #controls { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px; color: #888; font-size: 11px; z-index: 100; }
    #controls kbd { background: #333; padding: 2px 6px; border-radius: 3px; color: #fff; }
  </style>
  <script src="js/map_renderer.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const loadingStatusEl = document.getElementById('loadingStatus');
      const startBtn = document.getElementById('startBtn');

      if (window.assetManager) {
        const fallbackTimer = setTimeout(() => {
          if (loadingStatusEl) {
            loadingStatusEl.classList.add('error');
            loadingStatusEl.innerHTML = '‚ö† Timeout - using fallback';
          }
          if (startBtn) startBtn.disabled = false;
        }, 5000);

        assetManager.preload()
          .then(() => {
            clearTimeout(fallbackTimer);
            if (loadingStatusEl) {
              loadingStatusEl.classList.add('ready');
              loadingStatusEl.innerHTML = '‚úì Assets ready';
            }
            if (startBtn) startBtn.disabled = false;
          })
          .catch(() => {
            clearTimeout(fallbackTimer);
            if (loadingStatusEl) {
              loadingStatusEl.classList.add('error');
              loadingStatusEl.innerHTML = '‚ö† Assets failed - starting anyway';
            }
            if (startBtn) startBtn.disabled = false;
          });
      } else {
        setTimeout(() => { if (startBtn) startBtn.disabled = false; }, 2000);
      }
    });
  </script>
</head>
<body>
  <canvas id="game"></canvas>
  <canvas id="minimap" width="150" height="150"></canvas>

  <button id="soundToggle">üîä</button>

  <div id="ui">
    <h1>ü•© PUDGE WARS</h1>
    <p id="connectionStatus">Connecting...</p>
  </div>

  <div id="leaderboard">
    <h3>üèÜ Leaderboard</h3>
    <div id="lbList"></div>
  </div>

  <div id="stats">
    <div><span class="stat-label">Kills:</span> <span class="stat-value" id="kills">0</span></div>
    <div><span class="stat-label">Deaths:</span> <span class="stat-value" id="deaths">0</span></div>
    <div><span class="stat-label">Health:</span> <span class="stat-value" id="health">1000</span></div>
    <div><span class="stat-label">üí∞ Gold:</span> <span class="stat-value" id="gold">600</span></div>
  </div>

  <div id="hookIndicator" class="ready">ü™ù HOOK READY</div>
  <div id="hookCooldownBar"><div id="hookCooldownFill"></div></div>
  <div id="matchTimer">‚è±Ô∏è 7:00</div>

  <div id="gameOverScreen">
    <h1 id="gameOverTitle">üèÜ VICTORY!</h1>
    <p class="finalScore" id="finalScore">Radiant: 10 - Dire: 8</p>
    <p id="gameOverReason">Match ended</p>
    <button id="restartBtn">Play Again</button>
  </div>

  <div id="upgrades">
    <h3>‚¨ÜÔ∏è Upgrades</h3>
    <div class="upgrade-item" id="upgRange">
      <span class="upg-icon">üìè</span>
      <span class="upg-name">Range</span>
      <span class="upg-level" id="rangeLevel">1</span>
    </div>
    <div class="upgrade-item" id="upgSpeed">
      <span class="upg-icon">‚ö°</span>
      <span class="upg-name">Speed</span>
      <span class="upg-level" id="speedLevel">1</span>
    </div>
    <div class="upgrade-item" id="upgDamage">
      <span class="upg-icon">üíÄ</span>
      <span class="upg-name">Dmg</span>
      <span class="upg-level" id="damageLevel">1</span>
    </div>
    <div class="upgrade-item" id="upgCooldown">
      <span class="upg-icon">‚è±Ô∏è</span>
      <span class="upg-name">CD</span>
      <span class="upg-level" id="cdLevel">1</span>
    </div>
  </div>

  <div id="controls">
    <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move &nbsp;|&nbsp; <kbd>MOUSE</kbd> Aim &nbsp;|&nbsp; <kbd>CLICK</kbd> Hook
  </div>

  <div id="startScreen">
    <h1>ü•© PUDGE WARS</h1>
    <p>Hook enemies ‚Ä¢ Pull allies ‚Ä¢ Dominate the river</p>
    <input type="text" id="playerNameInput" placeholder="Enter your name..." maxlength="20" autocomplete="off">
    <button id="startBtn">Start Game</button>
    <div id="loadingStatus"><div class="spinner"></div> <span>Loading assets...</span></div>
    <div id="onlineStatus" style="color:#666;font-size:11px;margin-top:10px;">‚è≥ Checking online...</div>
  </div>

  <script>
    // ==========================================
    // –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø
    // ==========================================
    const CONFIG = {
      FIELD_SIZE: 2000,
      RIVER_Y: 1000,
      RIVER_WIDTH: 150,
      PLAYER_RADIUS: 18,
      PLAYER_SPEED: 4,
      PLAYER_HEALTH: 1000,
      HOOK_RANGE: 400,
      HOOK_SPEED: 15,
      HOOK_RADIUS: 6,
      HOOK_COOLDOWN: 3000,
      HOOK_DAMAGE: 300,
      HOOK_PULL_SPEED: 8
    };

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let ws = null;
    let myId = null;
    let gameRunning = false;
    let lastTime = 0;

    const state = {
      players: new Map(),
      hooks: [],
      myTeam: null,
      myStats: { kills: 0, deaths: 0 },
      gold: 600
    };

    const hookUpgrades = {
      range: { level: 1, max: 5, base: 400, step: 50, cost: 100 },
      speed: { level: 1, max: 5, base: 15, step: 2, cost: 150 },
      damage: { level: 1, max: 5, base: 300, step: 50, cost: 200 },
      cooldown: { level: 1, max: 5, base: 3000, step: -300, cost: 250 }
    };

    const input = {
      keys: {},
      mouseX: 0,
      mouseY: 0,
      hookRequested: false
    };

    const hookCooldownState = {
      onCooldown: false,
      cooldownEnd: 0
    };

    const matchState = {
      duration: 420000,
      remaining: 420000
    };

    const particles = [];
    const enemyArrows = new Map();
    const killStreak = { count: 0, lastKillTime: 0 };
    let firstBloodPlayed = false;

    let audioEnabled = true;
    let audioCtx = null;

    // ==========================================
    // –ê–£–î–ò–û –°–ò–°–¢–ï–ú–ê
    // ==========================================
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    function playSound(freq, type, duration, volume = 0.1) {
      if (!audioEnabled || !audioCtx) return;

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.type = type;
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    function playHookSound() { playSound(400, 'sawtooth', 0.2, 0.15); }
    function playHitSound() { playSound(200, 'square', 0.15, 0.2); }
    function playKillSound() {
      playSound(300, 'sawtooth', 0.1, 0.15);
      setTimeout(() => playSound(400, 'sawtooth', 0.2, 0.15), 100);
    }
    function playDeathSound() {
      playSound(200, 'sawtooth', 0.3, 0.2);
      setTimeout(() => playSound(150, 'sawtooth', 0.4, 0.2), 150);
    }
    function playSaveSound() {
      playSound(500, 'sine', 0.15, 0.1);
      setTimeout(() => playSound(700, 'sine', 0.2, 0.1), 100);
    }

    // ==========================================
    // –ö–õ–ê–°–°–´
    // ==========================================
    class Particle {
      constructor(x, y, color, speed, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = speed * (0.5 + Math.random() * 0.5);
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
        this.life = life;
        this.maxLife = life;
        this.size = 3 + Math.random() * 3;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.life--;
      }

      draw(ctx, cameraX, cameraY) {
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x - cameraX, this.y - cameraY, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    function createHitEffect(x, y, color) {
      for (let i = 0; i < 15; i++) {
        particles.push(new Particle(x, y, color, 5, 30));
      }
    }

    function createDeathEffect(x, y) {
      for (let i = 0; i < 30; i++) {
        particles.push(new Particle(x, y, '#8e44ad', 8, 50));
        particles.push(new Particle(x, y, '#e74c3c', 6, 40));
      }
    }

    class Player {
      constructor(data) {
        this.id = data[0];
        this.x = data[1];
        this.y = data[2];
        this.team = data[3];
        this.health = data[4];
        this.maxHealth = data[5];
        this.angle = 0;
        this.isDead = data[10] || false;
      }

      update() {
        if (this.id === myId) {
          this.angle = Math.atan2(input.mouseY - canvas.height/2, input.mouseX - canvas.width/2);
        }
      }

      draw(ctx, cameraX, cameraY) {
        const screenX = this.x - cameraX;
        const screenY = this.y - cameraY;

        if (this.id === myId) {
          const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, CONFIG.PLAYER_RADIUS * 2);
          gradient.addColorStop(0, 'rgba(241, 196, 15, 0.3)');
          gradient.addColorStop(1, 'rgba(241, 196, 15, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(screenX, screenY, CONFIG.PLAYER_RADIUS * 2, 0, Math.PI * 2);
          ctx.fill();
        }

        const hpPercent = this.health / this.maxHealth;
        if (hpPercent < 0.3 && this.id !== myId) {
          const dangerGradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, CONFIG.PLAYER_RADIUS * 2.5);
          dangerGradient.addColorStop(0, 'rgba(255, 0, 0, 0.4)');
          dangerGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
          ctx.fillStyle = dangerGradient;
          ctx.beginPath();
          ctx.arc(screenX, screenY, CONFIG.PLAYER_RADIUS * 2.5, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.beginPath();
        ctx.arc(screenX, screenY, CONFIG.PLAYER_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = this.team === 'radiant' ? '#2ecc71' : '#e74c3c';
        ctx.fill();

        ctx.lineWidth = 3;
        ctx.strokeStyle = this.id === myId ? '#f1c40f' : '#333';
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(screenX, screenY, CONFIG.PLAYER_RADIUS * 0.6, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(screenX, screenY);
        ctx.lineTo(
          screenX + Math.cos(this.angle) * CONFIG.PLAYER_RADIUS * 1.5,
          screenY + Math.sin(this.angle) * CONFIG.PLAYER_RADIUS * 1.5
        );
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();

        if (this.id === myId) {
          ctx.fillStyle = '#f1c40f';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('YOU', screenX, screenY - CONFIG.PLAYER_RADIUS - 8);
        }

        const hpBarWidth = 40;
        const hpBarPercent = this.health / this.maxHealth;
        ctx.fillStyle = '#333';
        ctx.fillRect(screenX - hpBarWidth/2, screenY + CONFIG.PLAYER_RADIUS + 5, hpBarWidth, 4);
        ctx.fillStyle = hpBarPercent > 0.5 ? '#2ecc71' : hpBarPercent > 0.25 ? '#f39c12' : '#e74c3c';
        ctx.fillRect(screenX - hpBarWidth/2, screenY + CONFIG.PLAYER_RADIUS + 5, hpBarWidth * hpBarPercent, 4);
      }
    }

    class Hook {
      constructor(data) {
        this.id = data[0];
        this.x = data[1];
        this.y = data[2];
        this.targetX = data[3];
        this.targetY = data[4];
        this.ownerId = data[5];
        this.state = 'flying';
        this.targetId = null;
        this.trail = [];

        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        const dist = Math.hypot(dx, dy);
        this.vx = (dx / dist) * CONFIG.HOOK_SPEED;
        this.vy = (dy / dist) * CONFIG.HOOK_SPEED;
        this.traveled = 0;
      }

      update() {
        if (this.state === 'flying') {
          this.trail.push({ x: this.x, y: this.y, life: 10 });
          this.x += this.vx;
          this.y += this.vy;
          this.traveled += CONFIG.HOOK_SPEED;

          if (this.traveled >= CONFIG.HOOK_RANGE) {
            this.state = 'returning';
          }
        } else if (this.state === 'returning' || this.state === 'pulling') {
          const owner = state.players.get(this.ownerId);
          if (owner) {
            const dx = owner.x - this.x;
            const dy = owner.y - this.y;
            const dist = Math.hypot(dx, dy);

            if (dist < 10) {
              this.state = 'done';
            } else {
              this.x += (dx / dist) * CONFIG.HOOK_PULL_SPEED;
              this.y += (dy / dist) * CONFIG.HOOK_PULL_SPEED;

              if (this.state === 'pulling' && this.targetId !== null) {
                const target = state.players.get(this.targetId);
                if (target) {
                  target.x = this.x;
                  target.y = this.y;
                }
              }
            }
          } else {
            this.state = 'done';
          }
        }

        for (let i = this.trail.length - 1; i >= 0; i--) {
          this.trail[i].life--;
          if (this.trail[i].life <= 0) {
            this.trail.splice(i, 1);
          }
        }
      }

      draw(ctx, cameraX, cameraY) {
        const screenX = this.x - cameraX;
        const screenY = this.y - cameraY;
        const owner = state.players.get(this.ownerId);

        if (!owner) return;

        const ownerScreenX = owner.x - cameraX;
        const ownerScreenY = owner.y - cameraY;

        for (const point of this.trail) {
          const alpha = point.life / 10;
          ctx.globalAlpha = alpha;
          ctx.fillStyle = '#e74c3c';
          ctx.beginPath();
          ctx.arc(point.x - cameraX, point.y - cameraY, CONFIG.HOOK_RADIUS * 0.7, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        ctx.beginPath();
        ctx.moveTo(ownerScreenX, ownerScreenY);
        ctx.lineTo(screenX, screenY);
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.beginPath();
        ctx.arc(screenX, screenY, CONFIG.HOOK_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = this.state === 'pulling' ? '#f39c12' : '#e74c3c';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(screenX - 2, screenY - 2, CONFIG.HOOK_RADIUS * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fill();
      }
    }

    // ==========================================
    // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
    // ==========================================
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ==========================================
    // –£–ü–†–ê–í–õ–ï–ù–ò–ï
    // ==========================================
    document.addEventListener('keydown', (e) => { input.keys[e.code] = true; });
    document.addEventListener('keyup', (e) => { input.keys[e.code] = false; });
    document.addEventListener('mousemove', (e) => {
      input.mouseX = e.clientX;
      input.mouseY = e.clientY;
    });
    document.addEventListener('mousedown', (e) => {
      if (e.button === 0 && gameRunning) {
        input.hookRequested = true;
      }
    });

    document.getElementById('startBtn').addEventListener('click', () => {
      const nameInput = document.getElementById('playerNameInput');
      const playerName = nameInput.value.trim() || `Pudge_${Math.floor(Math.random() * 1000)}`;

      document.getElementById('startScreen').classList.add('hidden');
      gameRunning = true;
      initAudio();
      connect();

      setTimeout(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'setName', name: playerName }));
        }
      }, 100);
    });

    document.getElementById('soundToggle').addEventListener('click', () => {
      audioEnabled = !audioEnabled;
      document.getElementById('soundToggle').textContent = audioEnabled ? 'üîä' : 'üîá';
    });

    document.getElementById('restartBtn').addEventListener('click', () => { location.reload(); });
    document.getElementById('upgRange').addEventListener('click', () => buyUpgrade('range'));
    document.getElementById('upgSpeed').addEventListener('click', () => buyUpgrade('speed'));
    document.getElementById('upgDamage').addEventListener('click', () => buyUpgrade('damage'));
    document.getElementById('upgCooldown').addEventListener('click', () => buyUpgrade('cooldown'));

    function buyUpgrade(type) {
      const upg = hookUpgrades[type];
      if (upg.level >= upg.max || state.gold < upg.cost) return;

      state.gold -= upg.cost;
      upg.level++;
      upg.cost = Math.floor(upg.cost * 1.5);

      ws.send(JSON.stringify({
        type: 'upgrade',
        upgradeType: type,
        value: getUpgradeValue(type)
      }));

      updateUpgradesUI();
      playSaveSound();
    }

    function getUpgradeValue(type) {
      const upg = hookUpgrades[type];
      return upg.base + (upg.step * (upg.level - 1));
    }

    function updateUpgradesUI() {
      for (const [type, upg] of Object.entries(hookUpgrades)) {
        const el = document.getElementById(`upg${type.charAt(0).toUpperCase() + type.slice(1)}`);
        const levelEl = document.getElementById(`${type}Level`);
        levelEl.textContent = upg.level;

        if (upg.level >= upg.max) {
          el.classList.add('maxed');
        }
      }

      CONFIG.HOOK_RANGE = getUpgradeValue('range');
      CONFIG.HOOK_SPEED = getUpgradeValue('speed');
      CONFIG.HOOK_DAMAGE = getUpgradeValue('damage');
      CONFIG.HOOK_COOLDOWN = getUpgradeValue('cooldown');
    }

    function updateLeaderboard(players) {
      const lbList = document.getElementById('lbList');
      if (!players || players.length === 0) return;

      const sorted = [...players].sort((a, b) => b[8] - a[8]);
      let html = '';

      for (let i = 0; i < Math.min(sorted.length, 10); i++) {
        const p = sorted[i];
        const [id, , , team, , , , , kills, deaths, , name] = p;
        const isMe = id === myId ? 'me' : '';
        const teamIcon = team === 'radiant' ? 'üü¢' : 'üî¥';

        html += `<div class="lb-row ${isMe}">
          <span class="lb-name">${i + 1}. ${teamIcon} ${name || `Pudge_${id}`}</span>
          <span class="lb-kills">‚öîÔ∏è ${kills}/${deaths}</span>
        </div>`;
      }

      lbList.innerHTML = html;
    }

    function updateEnemyArrows(cameraX, cameraY) {
      const player = state.players.get(myId);
      if (!player) return;

      const screenCX = canvas.width / 2;
      const screenCY = canvas.height / 2;
      const edgeDist = 80;

      document.querySelectorAll('.enemy-arrow').forEach(el => el.remove());
      enemyArrows.clear();

      for (const [id, p] of state.players) {
        if (id === myId || p.team === player.team || p.isDead) continue;

        const screenX = p.x - cameraX;
        const screenY = p.y - cameraY;

        if (screenX > 0 && screenX < canvas.width && screenY > 0 && screenY < canvas.height) continue;

        const dx = screenX - screenCX;
        const dy = screenY - screenCY;
        const angle = Math.atan2(dy, dx);

        let arrowX, arrowY;
        const absDx = Math.abs(dx);
        const absDy = Math.abs(dy);

        if (absDx / canvas.width > absDy / canvas.height) {
          arrowX = dx > 0 ? canvas.width - edgeDist : edgeDist;
          arrowY = screenCY + Math.tan(angle) * (arrowX - screenCX);
          arrowY = Math.max(edgeDist, Math.min(canvas.height - edgeDist, arrowY));
        } else {
          arrowY = dy > 0 ? canvas.height - edgeDist : edgeDist;
          arrowX = screenCX + (arrowY - screenCY) / Math.tan(angle);
          arrowX = Math.max(edgeDist, Math.min(canvas.width - edgeDist, arrowX));
        }

        const arrow = document.createElement('div');
        arrow.className = 'enemy-arrow';
        arrow.style.left = (arrowX - 10) + 'px';
        arrow.style.top = (arrowY - 10) + 'px';
        arrow.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
        document.body.appendChild(arrow);

        enemyArrows.set(id, arrow);
      }
    }

    // ==========================================
    // –°–ï–¢–ï–í–ê–Ø –õ–û–ì–ò–ö–ê
    // ==========================================
    function connect() {
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${location.host}`);

      ws.onopen = () => {
        document.getElementById('connectionStatus').textContent = 'Connected';
        document.getElementById('connectionStatus').style.color = '#2ecc71';
        const onlineStatusEl = document.getElementById('onlineStatus');
        if (onlineStatusEl) {
          onlineStatusEl.textContent = 'üü¢ Server connected';
          onlineStatusEl.style.color = '#2ecc71';
        }
      };

      ws.onmessage = (e) => {
        const data = JSON.parse(e.data);
        handleServerMessage(data);
      };

      ws.onclose = () => {
        document.getElementById('connectionStatus').textContent = 'Disconnected';
        document.getElementById('connectionStatus').style.color = '#e74c3c';
        gameRunning = false;
        const onlineStatusEl = document.getElementById('onlineStatus');
        if (onlineStatusEl) {
          onlineStatusEl.textContent = 'üî¥ Server disconnected';
          onlineStatusEl.style.color = '#e74c3c';
        }
      };
    }

    function handleServerMessage(data) {
      switch(data.type) {
        case 'welcome':
          myId = data.playerId;
          state.myTeam = data.team;
          matchState.remaining = data.matchTime || matchState.duration;
          for (const p of data.players) {
            state.players.set(p[0], new Player(p));
          }
          break;

        case 'state':
          const newPlayers = new Map();
          for (const p of data.players) {
            const existing = state.players.get(p[0]);
            if (existing) {
              existing.x = p[1];
              existing.y = p[2];
              existing.team = p[3];
              existing.health = p[4];
              existing.maxHealth = p[5];
              existing.isDead = p[10] || false;
              newPlayers.set(p[0], existing);
            } else {
              newPlayers.set(p[0], new Player(p));
            }
          }
          state.players = newPlayers;
          state.hooks = data.hooks.map(h => new Hook(h));

          const onlineStatusEl = document.getElementById('onlineStatus');
          if (onlineStatusEl && !gameRunning) {
            const online = state.players.size;
            onlineStatusEl.textContent = `üü¢ ${online} player${online !== 1 ? 's' : ''} online`;
            onlineStatusEl.style.color = online > 1 ? '#2ecc71' : '#f39c12';
          }

          if (data.stats && myId) {
            const myStats = data.stats.find(s => s[0] === myId);
            if (myStats) {
              state.myStats.kills = myStats[1];
              state.myStats.deaths = myStats[2];
            }
          }

          if (data.matchTime !== undefined) {
            matchState.remaining = data.matchTime;
          }

          updateLeaderboard(data.players);
          break;

        case 'event':
          handleGameEvent(data.event);
          break;
      }
    }

    function handleGameEvent(event) {
      switch (event.type) {
        case 'hookFire':
          if (event.playerId === myId) {
            startHookCooldown();
            playHookSound();
          }
          break;

        case 'hookHit': {
          const target = state.players.get(event.targetId);
          if (target) {
            createHitEffect(target.x, target.y, '#e74c3c');
            playHitSound();
            if (target.id === myId) {
              showNotification('HIT!', 'notify-hit');
            }
          }
          break;
        }

        case 'playerKill': {
          const victim = state.players.get(event.victimId);
          if (victim) {
            createDeathEffect(victim.x, victim.y);
            playKillSound();

            if (event.killerId === myId) {
              state.gold += 150;

              if (!firstBloodPlayed) {
                firstBloodPlayed = true;
                showNotification('ü©∏ FIRST BLOOD!', 'notify-kill');
              } else {
                handleKillStreak();
                showNotification('KILL! +150üí∞', 'notify-kill');
              }
            }

            if (event.assistIds?.includes(myId)) {
              state.gold += 50;
              showNotification('ASSIST! +50üí∞', 'notify-save');
            }
          }
          break;
        }

        case 'allySaved': {
          const ally = state.players.get(event.allyId);
          if (ally && ally.team === state.myTeam) {
            createHitEffect(ally.x, ally.y, '#2ecc71');
            playSaveSound();
            showNotification('SAVE!', 'notify-save');
          }
          break;
        }

        case 'matchEnd':
          showGameOver(event.winner === state.myTeam, event.radiantKills, event.direKills);
          break;

        case 'matchStart':
          firstBloodPlayed = false;
          killStreak.count = 0;
          break;
      }
    }

    function startHookCooldown() {
      hookCooldownState.onCooldown = true;
      hookCooldownState.cooldownEnd = Date.now() + CONFIG.HOOK_COOLDOWN;

      const indicator = document.getElementById('hookIndicator');
      const bar = document.getElementById('hookCooldownBar');

      indicator.textContent = '‚è≥ COOLDOWN...';
      indicator.className = 'cooldown';
      bar.style.display = 'block';
    }

    function updateHookCooldown() {
      const now = Date.now();
      const indicator = document.getElementById('hookIndicator');
      const bar = document.getElementById('hookCooldownBar');
      const fill = document.getElementById('hookCooldownFill');

      if (hookCooldownState.onCooldown) {
        const remaining = hookCooldownState.cooldownEnd - now;

        if (remaining <= 0) {
          hookCooldownState.onCooldown = false;
          indicator.textContent = 'ü™ù HOOK READY';
          indicator.className = 'ready';
          bar.style.display = 'none';
          fill.style.width = '100%';
        } else {
          const percent = (remaining / CONFIG.HOOK_COOLDOWN) * 100;
          fill.style.width = percent + '%';
        }
      }
    }

    function sendInput() {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      let dx = 0, dy = 0;
      if (input.keys['KeyW']) dy -= 1;
      if (input.keys['KeyS']) dy += 1;
      if (input.keys['KeyA']) dx -= 1;
      if (input.keys['KeyD']) dx += 1;

      if (dx !== 0 || dy !== 0) {
        const len = Math.hypot(dx, dy);
        dx /= len;
        dy /= len;
      }

      ws.send(JSON.stringify({ type: 'move', dx, dy }));

      if (input.hookRequested) {
        const angle = Math.atan2(input.mouseY - canvas.height/2, input.mouseX - canvas.width/2);
        ws.send(JSON.stringify({ type: 'hook', angle }));
        input.hookRequested = false;
      }
    }

    // ==========================================
    // –ö–ê–ú–ï–†–ê –ò –†–ï–ù–î–ï–†–ò–ù–ì
    // ==========================================
    function updateCamera() {
      const player = state.players.get(myId);
      if (!player) return { x: 0, y: 0 };

      return {
        x: player.x - canvas.width / 2,
        y: player.y - canvas.height / 2
      };
    }

    function drawMinimap() {
      const mmCanvas = document.getElementById('minimap');
      const mmCtx = mmCanvas.getContext('2d');
      const MM_SCALE = 150 / CONFIG.FIELD_SIZE;

      mmCtx.fillStyle = 'rgba(0,0,0,0.9)';
      mmCtx.fillRect(0, 0, 150, 150);

      mmCtx.fillStyle = 'rgba(52,152,219,0.5)';
      mmCtx.fillRect(0, (CONFIG.RIVER_Y - CONFIG.RIVER_WIDTH/2) * MM_SCALE, 150, CONFIG.RIVER_WIDTH * MM_SCALE);

      for (const player of state.players.values()) {
        mmCtx.fillStyle = player.team === 'radiant' ? '#2ecc71' : '#e74c3c';
        const size = player.id === myId ? 5 : 3;
        mmCtx.beginPath();
        mmCtx.arc(player.x * MM_SCALE, player.y * MM_SCALE, size, 0, Math.PI * 2);
        mmCtx.fill();
      }

      const player = state.players.get(myId);
      if (player) {
        const camX = player.x - canvas.width / 2;
        const camY = player.y - canvas.height / 2;
        mmCtx.strokeStyle = '#fff';
        mmCtx.lineWidth = 1;
        mmCtx.strokeRect(camX * MM_SCALE, camY * MM_SCALE, canvas.width * MM_SCALE, canvas.height * MM_SCALE);
      }
    }

    function updateAndDrawParticles(cameraX, cameraY) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update();
        p.draw(ctx, cameraX, cameraY);
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function showNotification(text, className) {
      const existing = document.getElementById('notification');
      if (existing) existing.remove();

      const el = document.createElement('div');
      el.id = 'notification';
      el.className = className;
      el.textContent = text;
      document.body.appendChild(el);

      setTimeout(() => el.remove(), 500);
    }

    function draw() {
      const camera = updateCamera();
      drawMap(camera.x, camera.y);
      updateAndDrawParticles(camera.x, camera.y);

      for (const hook of state.hooks) {
        hook.draw(ctx, camera.x, camera.y);
      }

      for (const player of state.players.values()) {
        player.update();
        player.draw(ctx, camera.x, camera.y);
      }

      drawMinimap();
      updateEnemyArrows(camera.x, camera.y);
      updateUI();
    }

    function updateUI() {
      const player = state.players.get(myId);
      if (player) {
        document.getElementById('health').textContent = Math.round(player.health);

        const hpPercent = player.health / player.maxHealth;
        const healthEl = document.getElementById('health');
        if (hpPercent < 0.25) {
          healthEl.style.color = '#f00';
          healthEl.style.animation = 'timerPulse 0.5s infinite';
        } else {
          healthEl.style.color = '#e74c3c';
          healthEl.style.animation = '';
        }
      }
      document.getElementById('kills').textContent = state.myStats.kills;
      document.getElementById('deaths').textContent = state.myStats.deaths;
      document.getElementById('gold').textContent = state.gold;
      updateHookCooldown();
      updateMatchTimer();
    }

    function updateMatchTimer() {
      const minutes = Math.floor(matchState.remaining / 60000);
      const seconds = Math.floor((matchState.remaining % 60000) / 1000);
      const timerEl = document.getElementById('matchTimer');
      timerEl.textContent = `‚è±Ô∏è ${minutes}:${seconds.toString().padStart(2, '0')}`;

      if (matchState.remaining < 60000) {
        timerEl.classList.add('urgent');
      } else {
        timerEl.classList.remove('urgent');
      }
    }

    function showGameOver(victory, radiantKills, direKills) {
      const screen = document.getElementById('gameOverScreen');
      const title = document.getElementById('gameOverTitle');
      const score = document.getElementById('finalScore');

      screen.classList.add('show');
      screen.className = victory ? 'victory' : 'defeat';
      title.textContent = victory ? 'üèÜ VICTORY!' : 'üíÄ DEFEAT';
      score.textContent = `Radiant: ${radiantKills} - Dire: ${direKills}`;

      playKillSound();
    }

    function handleKillStreak() {
      const now = Date.now();
      const timeSinceLastKill = now - killStreak.lastKillTime;

      if (timeSinceLastKill < 10000) {
        killStreak.count++;

        const notifications = {
          2: ['üî• DOUBLE KILL!', 'doubleKill', 'üî• Double Kill'],
          3: ['üíÄ TRIPLE KILL!', 'tripleKill', 'üíÄ Triple Kill'],
          4: ['üëª QUADRA KILL!', 'quadraKill', 'üëª Quadra Kill'],
          5: ['‚ö° PENTA KILL!', 'pentaKill', '‚ö° Penta Kill']
        };

        if (notifications[killStreak.count]) {
          const [msg, , achievement] = notifications[killStreak.count];
          showNotification(msg, 'notify-kill');
          playKillSound();
          unlockAchievement(killStreak.count === 2 ? 'doubleKill' : killStreak.count === 3 ? 'tripleKill' : killStreak.count === 4 ? 'quadraKill' : 'pentaKill', achievement);
        } else if (killStreak.count >= 6) {
          showNotification(`‚ö° ${killStreak.count}x KILL STREAK!`, 'notify-kill');
          playKillSound();
          unlockAchievement('killingSpree', '‚ö° Killing Spree');
        }
      } else {
        killStreak.count = 1;
      }

      killStreak.lastKillTime = now;
    }

    function unlockAchievement(id, name) {
      const saved = JSON.parse(localStorage.getItem('pudgeAchievements') || '{}');
      if (!saved[id]) {
        saved[id] = true;
        localStorage.setItem('pudgeAchievements', JSON.stringify(saved));
        showNotification(`üèÜ ACHIEVEMENT: ${name}`, 'notify-save');
        playSaveSound();
      }
    }

    // ==========================================
    // –ò–ì–†–û–í–û–ô –¶–ò–ö–õ
    // ==========================================
    function gameLoop(timestamp) {
      lastTime = timestamp;

      if (gameRunning) {
        sendInput();
        draw();
      }

      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
