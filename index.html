<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pudge Wars - Hook Battle</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #1a1a2e; font-family: 'Segoe UI', sans-serif; }
    canvas { display: block; }

    /* –ë–∞–∑–æ–≤—ã–π UI */
    #ui { position: fixed; top: 10px; left: 10px; color: #fff; z-index: 100; pointer-events: none; }
    #ui h1 { font-size: 24px; color: #e74c3c; text-shadow: 0 0 10px rgba(231,76,60,0.5); margin-bottom: 5px; }
    #ui p { font-size: 12px; color: #888; }

    #stats { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px 15px; border-radius: 8px; color: #fff; z-index: 100; }
    #stats div { margin: 3px 0; font-size: 13px; }
    .stat-label { color: #888; }
    .stat-value { color: #e74c3c; font-weight: bold; }
    
    /* –õ–∏–¥–µ—Ä–±–æ—Ä–¥ */
    #leaderboard { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); border: 2px solid #444; border-radius: 8px; padding: 10px 20px; z-index: 100; min-width: 300px; }
    #leaderboard h3 { color: #e74c3c; font-size: 12px; margin: 0 0 8px 0; text-align: center; text-transform: uppercase; }
    .lb-row { display: flex; justify-content: space-between; padding: 3px 0; font-size: 11px; }
    .lb-row.me { background: rgba(241, 196, 15, 0.2); padding: 3px 8px; margin: 0 -8px; border-radius: 4px; }
    .lb-name { color: #aaa; }
    .lb-kills { color: #e74c3c; }
    .lb-team-radiant { color: #2ecc71; }
    .lb-team-dire { color: #e74c3c; }

    #hookIndicator { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 8px 20px; border-radius: 20px; color: #fff; font-size: 14px; z-index: 100; transition: all 0.2s; }
    #hookIndicator.ready { border: 2px solid #2ecc71; box-shadow: 0 0 10px rgba(46,204,113,0.5); }
    #hookIndicator.cooldown { border: 2px solid #e74c3c; opacity: 0.7; }
    #hookCooldownBar { position: fixed; bottom: 55px; left: 50%; transform: translateX(-50%); width: 150px; height: 6px; background: rgba(0,0,0,0.7); border-radius: 3px; overflow: hidden; z-index: 100; display: none; }
    #hookCooldownFill { height: 100%; background: linear-gradient(90deg, #e74c3c, #f39c12); width: 100%; transition: width 0.05s linear; }
    
    /* –¢–∞–π–º–µ—Ä –º–∞—Ç—á–∞ */
    #matchTimer { position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); border: 2px solid #e74c3c; border-radius: 8px; padding: 8px 20px; color: #fff; font-size: 18px; font-weight: bold; z-index: 100; }
    #matchTimer.urgent { border-color: #f00; color: #f00; animation: timerPulse 0.5s infinite; }
    @keyframes timerPulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }
    
    /* –≠–∫—Ä–∞–Ω –∫–æ–Ω—Ü–∞ –∏–≥—Ä—ã */
    #gameOverScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; }
    #gameOverScreen.show { display: flex; }
    #gameOverScreen h1 { font-size: 64px; margin-bottom: 20px; }
    #gameOverScreen.victory h1 { color: #2ecc71; text-shadow: 0 0 30px rgba(46,204,113,0.6); }
    #gameOverScreen.defeat h1 { color: #e74c3c; text-shadow: 0 0 30px rgba(231,76,60,0.6); }
    #gameOverScreen p { color: #aaa; font-size: 18px; margin-bottom: 30px; }
    #gameOverScreen .finalScore { font-size: 24px; color: #f1c40f; margin-bottom: 20px; }
    #restartBtn { padding: 15px 40px; font-size: 18px; font-weight: bold; color: #fff; background: linear-gradient(135deg, #e74c3c, #c0392b); border: none; border-radius: 8px; cursor: pointer; }
    #restartBtn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(231,76,60,0.5); }
    
    /* –ü–∞–Ω–µ–ª—å –ø—Ä–æ–∫–∞—á–∫–∏ */
    #upgrades { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); border: 2px solid #e74c3c; border-radius: 12px; padding: 10px 15px; z-index: 100; display: flex; gap: 10px; align-items: center; }
    #upgrades h3 { color: #e74c3c; font-size: 12px; margin: 0 10px 0 0; text-transform: uppercase; }
    .upgrade-item { background: rgba(40,20,20,0.8); border: 1px solid #633; border-radius: 6px; padding: 6px 10px; cursor: pointer; transition: all 0.2s; display: flex; flex-direction: column; align-items: center; min-width: 50px; }
    .upgrade-item:hover { background: rgba(60,30,30,0.9); border-color: #e74c3c; transform: translateY(-2px); }
    .upgrade-item.maxed { opacity: 0.5; cursor: default; border-color: #444; }
    .upg-icon { font-size: 16px; }
    .upg-name { color: #aaa; font-size: 9px; text-transform: uppercase; }
    .upg-level { color: #e74c3c; font-size: 14px; font-weight: bold; }
    
    /* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –≤—Ä–∞–≥–æ–≤ */
    .enemy-arrow { position: fixed; width: 0; height: 0; pointer-events: none; z-index: 90; }
    .enemy-arrow::after { content: ''; position: absolute; width: 20px; height: 20px; border: 3px solid #e74c3c; border-radius: 50%; border-left-color: transparent; border-top-color: transparent; transform: rotate(-45deg); }
    
    /* –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è */
    #notification { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 48px; font-weight: bold; text-align: center; z-index: 1000; pointer-events: none; text-shadow: 0 0 30px rgba(0,0,0,0.8); animation: notifyPop 0.5s ease-out forwards; }
    @keyframes notifyPop { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 0; } }
    .notify-hit { color: #e74c3c; }
    .notify-kill { color: #f39c12; }
    .notify-death { color: #8e44ad; }
    .notify-save { color: #2ecc71; }
    
    /* –ú–∏–Ω–∏–∫–∞—Ä—Ç–∞ */
    #minimap { position: fixed; top: 10px; right: 10px; width: 150px; height: 150px; background: rgba(0,0,0,0.8); border: 2px solid #444; border-radius: 8px; z-index: 100; }
    
    /* –ó–≤—É–∫ */
    #soundToggle { position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); border: 2px solid #444; border-radius: 8px; padding: 8px 12px; color: #fff; cursor: pointer; z-index: 100; font-size: 18px; }
    #soundToggle:hover { border-color: #e74c3c; }
    
    #startScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
    #startScreen.hidden { display: none; }
    #startScreen h1 { font-size: 48px; color: #e74c3c; margin-bottom: 20px; text-shadow: 0 0 30px rgba(231,76,60,0.6); }
    #startScreen p { color: #aaa; margin-bottom: 30px; font-size: 14px; }
    #startScreen input { padding: 12px 20px; font-size: 16px; background: rgba(40,20,20,0.8); border: 2px solid #633; border-radius: 8px; color: #fff; margin-bottom: 15px; text-align: center; }
    #startScreen input:focus { outline: none; border-color: #e74c3c; }
    #startScreen input::placeholder { color: #644; }
    #startBtn { padding: 15px 40px; font-size: 18px; font-weight: bold; color: #fff; background: linear-gradient(135deg, #e74c3c, #c0392b); border: none; border-radius: 8px; cursor: pointer; text-transform: uppercase; }
    #startBtn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(231,76,60,0.5); }
    
    #controls { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px; color: #888; font-size: 11px; z-index: 100; }
    #controls kbd { background: #333; padding: 2px 6px; border-radius: 3px; color: #fff; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <canvas id="minimap" width="150" height="150"></canvas>
  
  <button id="soundToggle">üîä</button>
  
  <div id="ui">
    <h1>ü•© PUDGE WARS</h1>
    <p id="connectionStatus">Connecting...</p>
  </div>
  
  <!-- –õ–∏–¥–µ—Ä–±–æ—Ä–¥ -->
  <div id="leaderboard">
    <h3>üèÜ Leaderboard</h3>
    <div id="lbList"></div>
  </div>
  
  <div id="stats">
    <div><span class="stat-label">Kills:</span> <span class="stat-value" id="kills">0</span></div>
    <div><span class="stat-label">Deaths:</span> <span class="stat-value" id="deaths">0</span></div>
    <div><span class="stat-label">Health:</span> <span class="stat-value" id="health">1000</span></div>
    <div><span class="stat-label">üí∞ Gold:</span> <span class="stat-value" id="gold">600</span></div>
  </div>
  
  <div id="hookIndicator" class="ready">ü™ù HOOK READY</div>
  <div id="hookCooldownBar"><div id="hookCooldownFill"></div></div>
  <div id="matchTimer">‚è±Ô∏è 7:00</div>
  
  <!-- –≠–∫—Ä–∞–Ω –∫–æ–Ω—Ü–∞ –∏–≥—Ä—ã -->
  <div id="gameOverScreen">
    <h1 id="gameOverTitle">üèÜ VICTORY!</h1>
    <p class="finalScore" id="finalScore">Radiant: 10 - Dire: 8</p>
    <p id="gameOverReason">Match ended</p>
    <button id="restartBtn">Play Again</button>
  </div>
  
  <!-- –ü–∞–Ω–µ–ª—å –ø—Ä–æ–∫–∞—á–∫–∏ -->
  <div id="upgrades">
    <h3>‚¨ÜÔ∏è Upgrades</h3>
    <div class="upgrade-item" id="upgRange">
      <span class="upg-icon">üìè</span>
      <span class="upg-name">Range</span>
      <span class="upg-level" id="rangeLevel">1</span>
    </div>
    <div class="upgrade-item" id="upgSpeed">
      <span class="upg-icon">‚ö°</span>
      <span class="upg-name">Speed</span>
      <span class="upg-level" id="speedLevel">1</span>
    </div>
    <div class="upgrade-item" id="upgDamage">
      <span class="upg-icon">üíÄ</span>
      <span class="upg-name">Dmg</span>
      <span class="upg-level" id="damageLevel">1</span>
    </div>
    <div class="upgrade-item" id="upgCooldown">
      <span class="upg-icon">‚è±Ô∏è</span>
      <span class="upg-name">CD</span>
      <span class="upg-level" id="cdLevel">1</span>
    </div>
  </div>
  
  <div id="controls">
    <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move &nbsp;|&nbsp; <kbd>MOUSE</kbd> Aim &nbsp;|&nbsp; <kbd>CLICK</kbd> Hook
  </div>

  <div id="startScreen">
    <h1>ü•© PUDGE WARS</h1>
    <p>Hook enemies ‚Ä¢ Pull allies ‚Ä¢ Dominate the river</p>
    <input type="text" id="playerNameInput" placeholder="Enter your name..." maxlength="20" autocomplete="off">
    <button id="startBtn">Start Game</button>
  </div>

  <script>
    // ==========================================
    // –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò –ö–û–ù–°–¢–ê–ù–¢–´
    // ==========================================
    const CONFIG = {
      FIELD_SIZE: 2000,
      RIVER_Y: 1000,
      RIVER_WIDTH: 150,
      PLAYER_RADIUS: 18,
      PLAYER_SPEED: 4,
      PLAYER_HEALTH: 1000,
      HOOK_RANGE: 400,
      HOOK_SPEED: 15,
      HOOK_RADIUS: 6,
      HOOK_COOLDOWN: 3000,
      HOOK_DAMAGE: 300,
      HOOK_PULL_SPEED: 8,
      TEAM_RADIANT: 'radiant',
      TEAM_DIRE: 'dire'
    };

    // ==========================================
    // –°–ò–°–¢–ï–ú–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï
    // ==========================================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let ws = null;
    let myId = null;
    let gameRunning = false;
    let lastTime = 0;

    // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
    const state = {
      players: new Map(),
      hooks: [],
      myTeam: null,
      myStats: { kills: 0, deaths: 0 },
      gold: 600,
      level: 1
    };
    
    // –ü—Ä–æ–∫–∞—á–∫–∞ —Ö—É–∫–∞
    const hookUpgrades = {
      range: { level: 1, max: 5, base: 400, step: 50, cost: 100 },
      speed: { level: 1, max: 5, base: 15, step: 2, cost: 150 },
      damage: { level: 1, max: 5, base: 300, step: 50, cost: 200 },
      cooldown: { level: 1, max: 5, base: 3000, step: -300, cost: 250 }
    };

    // –í–≤–æ–¥
    const input = {
      keys: {},
      mouseX: 0,
      mouseY: 0,
      hookRequested: false
    };
    
    // –ö—É–ª–¥–∞—É–Ω —Ö—É–∫–∞
    const hookCooldownState = {
      onCooldown: false,
      cooldownEnd: 0
    };
    
    // –¢–∞–π–º–µ—Ä –º–∞—Ç—á–∞
    const matchState = {
      duration: 420000, // 7 –º–∏–Ω—É—Ç
      startTime: 0,
      remaining: 420000
    };
    
    // –°–∏—Å—Ç–µ–º–∞ —á–∞—Å—Ç–∏—Ü
    const particles = [];
    
    // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –≤—Ä–∞–≥–æ–≤
    const enemyArrows = new Map();
    
    // –ê—É–¥–∏–æ—Å–∏—Å—Ç–µ–º–∞
    let audioEnabled = true;
    let audioCtx = null;
    
    /**
     * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—É–¥–∏–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
     */
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }
    
    /**
     * –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Ç–æ–Ω–∞ (—Å–∏–Ω—Ç–µ–∑–∞—Ç–æ—Ä)
     */
    function playSound(freq, type, duration, volume = 0.1) {
      if (!audioEnabled || !audioCtx) return;
      
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      
      osc.type = type;
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
      
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }
    
    /**
     * –ó–≤—É–∫ –≤—ã—Å—Ç—Ä–µ–ª–∞ –∫—Ä—é–∫–æ–º
     */
    function playHookSound() {
      playSound(400, 'sawtooth', 0.2, 0.15);
    }
    
    /**
     * –ó–≤—É–∫ –ø–æ–ø–∞–¥–∞–Ω–∏—è
     */
    function playHitSound() {
      playSound(200, 'square', 0.15, 0.2);
    }
    
    /**
     * –ó–≤—É–∫ —É–±–∏–π—Å—Ç–≤–∞
     */
    function playKillSound() {
      playSound(300, 'sawtooth', 0.1, 0.15);
      setTimeout(() => playSound(400, 'sawtooth', 0.2, 0.15), 100);
    }
    
    /**
     * –ó–≤—É–∫ —Å–º–µ—Ä—Ç–∏
     */
    function playDeathSound() {
      playSound(200, 'sawtooth', 0.3, 0.2);
      setTimeout(() => playSound(150, 'sawtooth', 0.4, 0.2), 150);
    }
    
    /**
     * –ó–≤—É–∫ —Å–ø–∞—Å–µ–Ω–∏—è
     */
    function playSaveSound() {
      playSound(500, 'sine', 0.15, 0.1);
      setTimeout(() => playSound(700, 'sine', 0.2, 0.1), 100);
    }

    // ==========================================
    // –ö–õ–ê–°–°–´
    // ==========================================
    
    /**
     * –ß–∞—Å—Ç–∏—Ü–∞ –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
     */
    class Particle {
      constructor(x, y, color, speed, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = speed * (0.5 + Math.random() * 0.5);
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
        this.life = life;
        this.maxLife = life;
        this.size = 3 + Math.random() * 3;
      }
      
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.life--;
      }
      
      draw(ctx, cameraX, cameraY) {
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x - cameraX, this.y - cameraY, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
    
    /**
     * –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è –∫—Ä—é–∫–∞
     */
    function createHitEffect(x, y, color) {
      for (let i = 0; i < 15; i++) {
        particles.push(new Particle(x, y, color, 5, 30));
      }
    }
    
    /**
     * –≠—Ñ—Ñ–µ–∫—Ç —Å–º–µ—Ä—Ç–∏
     */
    function createDeathEffect(x, y) {
      for (let i = 0; i < 30; i++) {
        particles.push(new Particle(x, y, '#8e44ad', 8, 50));
        particles.push(new Particle(x, y, '#e74c3c', 6, 40));
      }
    }
    
    /**
     * –ò–≥—Ä–æ–∫ (Pudge)
     */
    class Player {
      constructor(data) {
        this.id = data[0];
        this.x = data[1];
        this.y = data[2];
        this.team = data[3];
        this.health = data[4];
        this.maxHealth = data[5];
        this.angle = 0;
        this.isDead = false;
      }
      
      update(dt) {
        if (this.id === myId) {
          const targetAngle = Math.atan2(input.mouseY - canvas.height/2, input.mouseX - canvas.width/2);
          this.angle = targetAngle;
        }
      }
      
      draw(ctx, cameraX, cameraY) {
        const screenX = this.x - cameraX;
        const screenY = this.y - cameraY;

        // –°–≤–µ—á–µ–Ω–∏–µ –¥–ª—è —Å–≤–æ–µ–≥–æ –∏–≥—Ä–æ–∫–∞
        if (this.id === myId) {
          const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, CONFIG.PLAYER_RADIUS * 2);
          gradient.addColorStop(0, 'rgba(241, 196, 15, 0.3)');
          gradient.addColorStop(1, 'rgba(241, 196, 15, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(screenX, screenY, CONFIG.PLAYER_RADIUS * 2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∏–∑–∫–æ–≥–æ –∑–¥–æ—Ä–æ–≤—å—è (–∫—Ä–∞—Å–Ω–∞—è –∞—É—Ä–∞)
        const hpPercent = this.health / this.maxHealth;
        if (hpPercent < 0.3 && this.id !== myId) {
          const dangerGradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, CONFIG.PLAYER_RADIUS * 2.5);
          dangerGradient.addColorStop(0, 'rgba(255, 0, 0, 0.4)');
          dangerGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
          ctx.fillStyle = dangerGradient;
          ctx.beginPath();
          ctx.arc(screenX, screenY, CONFIG.PLAYER_RADIUS * 2.5, 0, Math.PI * 2);
          ctx.fill();
        }

        // –¢–µ–ª–æ
        ctx.beginPath();
        ctx.arc(screenX, screenY, CONFIG.PLAYER_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = this.team === CONFIG.TEAM_RADIANT ? '#2ecc71' : '#e74c3c';
        ctx.fill();
        
        // –û–±–≤–æ–¥–∫–∞
        ctx.lineWidth = 3;
        ctx.strokeStyle = this.id === myId ? '#f1c40f' : '#333';
        ctx.stroke();
        
        // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫—Ä—É–≥
        ctx.beginPath();
        ctx.arc(screenX, screenY, CONFIG.PLAYER_RADIUS * 0.6, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fill();

        // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∑–≥–ª—è–¥–∞
        ctx.beginPath();
        ctx.moveTo(screenX, screenY);
        ctx.lineTo(
          screenX + Math.cos(this.angle) * CONFIG.PLAYER_RADIUS * 1.5,
          screenY + Math.sin(this.angle) * CONFIG.PLAYER_RADIUS * 1.5
        );
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä "YOU"
        if (this.id === myId) {
          ctx.fillStyle = '#f1c40f';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('YOU', screenX, screenY - CONFIG.PLAYER_RADIUS - 8);
        }

        // –ü–æ–ª–æ—Å–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è
        const hpBarWidth = 40;
        const hpPercent = this.health / this.maxHealth;
        ctx.fillStyle = '#333';
        ctx.fillRect(screenX - hpBarWidth/2, screenY + CONFIG.PLAYER_RADIUS + 5, hpBarWidth, 4);
        ctx.fillStyle = hpPercent > 0.5 ? '#2ecc71' : hpPercent > 0.25 ? '#f39c12' : '#e74c3c';
        ctx.fillRect(screenX - hpBarWidth/2, screenY + CONFIG.PLAYER_RADIUS + 5, hpBarWidth * hpPercent, 4);
      }
    }

    /**
     * –ö—Ä—é–∫ (Meat Hook)
     */
    class Hook {
      constructor(data) {
        this.id = data[0];
        this.x = data[1];
        this.y = data[2];
        this.targetX = data[3];
        this.targetY = data[4];
        this.ownerId = data[5];
        this.state = 'flying';
        this.targetId = null;
        this.trail = [];

        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        const dist = Math.hypot(dx, dy);
        this.vx = (dx / dist) * CONFIG.HOOK_SPEED;
        this.vy = (dy / dist) * CONFIG.HOOK_SPEED;
        this.traveled = 0;
      }

      update(dt) {
        if (this.state === 'flying') {
          this.trail.push({ x: this.x, y: this.y, life: 10 });
          this.x += this.vx;
          this.y += this.vy;
          this.traveled += CONFIG.HOOK_SPEED;

          if (this.traveled >= CONFIG.HOOK_RANGE) {
            this.state = 'returning';
          }
        } else if (this.state === 'returning' || this.state === 'pulling') {
          const owner = state.players.get(this.ownerId);
          if (owner) {
            const dx = owner.x - this.x;
            const dy = owner.y - this.y;
            const dist = Math.hypot(dx, dy);

            if (dist < 10) {
              this.state = 'done';
            } else {
              this.x += (dx / dist) * CONFIG.HOOK_PULL_SPEED;
              this.y += (dy / dist) * CONFIG.HOOK_PULL_SPEED;

              if (this.state === 'pulling' && this.targetId !== null) {
                const target = state.players.get(this.targetId);
                if (target) {
                  target.x = this.x;
                  target.y = this.y;
                }
              }
            }
          } else {
            this.state = 'done';
          }
        }
        
        for (let i = this.trail.length - 1; i >= 0; i--) {
          this.trail[i].life--;
          if (this.trail[i].life <= 0) {
            this.trail.splice(i, 1);
          }
        }
      }

      draw(ctx, cameraX, cameraY) {
        const screenX = this.x - cameraX;
        const screenY = this.y - cameraY;
        const owner = state.players.get(this.ownerId);

        if (!owner) return;

        const ownerScreenX = owner.x - cameraX;
        const ownerScreenY = owner.y - cameraY;
        
        // –°–ª–µ–¥
        for (const point of this.trail) {
          const alpha = point.life / 10;
          ctx.globalAlpha = alpha;
          ctx.fillStyle = '#e74c3c';
          ctx.beginPath();
          ctx.arc(point.x - cameraX, point.y - cameraY, CONFIG.HOOK_RADIUS * 0.7, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        // –¶–µ–ø—å
        ctx.beginPath();
        ctx.moveTo(ownerScreenX, ownerScreenY);
        ctx.lineTo(screenX, screenY);
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);

        // –ö—Ä—é–∫
        ctx.beginPath();
        ctx.arc(screenX, screenY, CONFIG.HOOK_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = this.state === 'pulling' ? '#f39c12' : '#e74c3c';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // –ë–ª–µ—Å–∫
        ctx.beginPath();
        ctx.arc(screenX - 2, screenY - 2, CONFIG.HOOK_RADIUS * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fill();
      }
    }

    // ==========================================
    // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
    // ==========================================
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ==========================================
    // –£–ü–†–ê–í–õ–ï–ù–ò–ï
    // ==========================================
    document.addEventListener('keydown', (e) => {
      input.keys[e.code] = true;
    });

    document.addEventListener('keyup', (e) => {
      input.keys[e.code] = false;
    });

    document.addEventListener('mousemove', (e) => {
      input.mouseX = e.clientX;
      input.mouseY = e.clientY;
    });

    document.addEventListener('mousedown', (e) => {
      if (e.button === 0 && gameRunning) {
        input.hookRequested = true;
      }
    });

    document.getElementById('startBtn').addEventListener('click', () => {
      const nameInput = document.getElementById('playerNameInput');
      const playerName = nameInput.value.trim() || `Pudge_${Math.floor(Math.random() * 1000)}`;
      
      document.getElementById('startScreen').classList.add('hidden');
      gameRunning = true;
      initAudio();
      connect();
      
      setTimeout(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'setName', name: playerName }));
        }
      }, 100);
    });
    
    document.getElementById('soundToggle').addEventListener('click', () => {
      audioEnabled = !audioEnabled;
      document.getElementById('soundToggle').textContent = audioEnabled ? 'üîä' : 'üîá';
    });
    
    document.getElementById('restartBtn').addEventListener('click', () => {
      location.reload();
    });
    
    document.getElementById('upgRange').addEventListener('click', () => buyUpgrade('range'));
    document.getElementById('upgSpeed').addEventListener('click', () => buyUpgrade('speed'));
    document.getElementById('upgDamage').addEventListener('click', () => buyUpgrade('damage'));
    document.getElementById('upgCooldown').addEventListener('click', () => buyUpgrade('cooldown'));
    
    function buyUpgrade(type) {
      const upg = hookUpgrades[type];
      if (upg.level >= upg.max) return;
      if (state.gold < upg.cost) return;
      
      state.gold -= upg.cost;
      upg.level++;
      upg.cost = Math.floor(upg.cost * 1.5);
      
      ws.send(JSON.stringify({
        type: 'upgrade',
        upgradeType: type,
        value: getUpgradeValue(type)
      }));
      
      updateUpgradesUI();
      playSaveSound();
    }
    
    function getUpgradeValue(type) {
      const upg = hookUpgrades[type];
      return upg.base + (upg.step * (upg.level - 1));
    }
    
    function updateUpgradesUI() {
      for (const [type, upg] of Object.entries(hookUpgrades)) {
        const el = document.getElementById(`upg${type.charAt(0).toUpperCase() + type.slice(1)}`);
        const levelEl = document.getElementById(`${type}Level`);
        levelEl.textContent = upg.level;
        
        if (upg.level >= upg.max) {
          el.classList.add('maxed');
          el.title = 'MAX';
        } else {
          el.title = `Cost: ${upg.cost} gold`;
        }
      }
      
      CONFIG.HOOK_RANGE = getUpgradeValue('range');
      CONFIG.HOOK_SPEED = getUpgradeValue('speed');
      CONFIG.HOOK_DAMAGE = getUpgradeValue('damage');
      CONFIG.HOOK_COOLDOWN = getUpgradeValue('cooldown');
    }
    
    function updateLeaderboard(players) {
      const lbList = document.getElementById('lbList');
      if (!players || players.length === 0) return;
      
      const sorted = [...players].sort((a, b) => b[8] - a[8]);
      
      let html = '';
      for (let i = 0; i < Math.min(sorted.length, 10); i++) {
        const p = sorted[i];
        const [id, x, y, team, health, maxHealth, gold, level, kills, deaths, isDead, name] = p;
        const isMe = id === myId ? 'me' : '';
        const teamIcon = team === 'radiant' ? 'üü¢' : 'üî¥';
        
        html += `<div class="lb-row ${isMe}">
          <span class="lb-name">${i + 1}. ${teamIcon} ${name || `Pudge_${id}`}</span>
          <span class="lb-kills">‚öîÔ∏è ${kills}/${deaths}</span>
        </div>`;
      }
      
      lbList.innerHTML = html;
    }
    
    function updateEnemyArrows(cameraX, cameraY) {
      const player = state.players.get(myId);
      if (!player) return;
      
      const screenCX = canvas.width / 2;
      const screenCY = canvas.height / 2;
      const edgeDist = 80;
      
      document.querySelectorAll('.enemy-arrow').forEach(el => el.remove());
      enemyArrows.clear();
      
      for (const [id, p] of state.players) {
        if (id === myId || p.team === player.team || p.isDead) continue;
        
        const screenX = p.x - cameraX;
        const screenY = p.y - cameraY;
        
        if (screenX > 0 && screenX < canvas.width && screenY > 0 && screenY < canvas.height) {
          continue;
        }
        
        const dx = screenX - screenCX;
        const dy = screenY - screenCY;
        const angle = Math.atan2(dy, dx);
        
        let arrowX, arrowY;
        const absDx = Math.abs(dx);
        const absDy = Math.abs(dy);
        
        if (absDx / canvas.width > absDy / canvas.height) {
          arrowX = dx > 0 ? canvas.width - edgeDist : edgeDist;
          arrowY = screenCY + Math.tan(angle) * (arrowX - screenCX);
          arrowY = Math.max(edgeDist, Math.min(canvas.height - edgeDist, arrowY));
        } else {
          arrowY = dy > 0 ? canvas.height - edgeDist : edgeDist;
          arrowX = screenCX + (arrowY - screenCY) / Math.tan(angle);
          arrowX = Math.max(edgeDist, Math.min(canvas.width - edgeDist, arrowX));
        }
        
        const arrow = document.createElement('div');
        arrow.className = 'enemy-arrow';
        arrow.style.left = (arrowX - 10) + 'px';
        arrow.style.top = (arrowY - 10) + 'px';
        arrow.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
        document.body.appendChild(arrow);
        
        enemyArrows.set(id, arrow);
      }
    }

    // ==========================================
    // –°–ï–¢–ï–í–û–ï –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–ï
    // ==========================================
    function connect() {
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${location.host}`);

      ws.onopen = () => {
        document.getElementById('connectionStatus').textContent = 'Connected';
        document.getElementById('connectionStatus').style.color = '#2ecc71';
      };

      ws.onmessage = (e) => {
        const data = JSON.parse(e.data);
        handleServerMessage(data);
      };

      ws.onclose = () => {
        document.getElementById('connectionStatus').textContent = 'Disconnected';
        document.getElementById('connectionStatus').style.color = '#e74c3c';
        gameRunning = false;
      };
    }

    function handleServerMessage(data) {
      switch(data.type) {
        case 'welcome':
          myId = data.playerId;
          myTeam = data.team;
          state.myTeam = data.team;
          matchState.remaining = data.matchTime || matchState.duration;
          matchState.startTime = Date.now();
          for (const p of data.players) {
            state.players.set(p[0], new Player(p));
          }
          break;

        case 'state':
          const newPlayers = new Map();
          for (const p of data.players) {
            const existing = state.players.get(p[0]);
            if (existing) {
              existing.x = p[1];
              existing.y = p[2];
              existing.team = p[3];
              existing.health = p[4];
              existing.maxHealth = p[5];
              newPlayers.set(p[0], existing);
            } else {
              newPlayers.set(p[0], new Player(p));
            }
          }
          state.players = newPlayers;
          state.hooks = data.hooks.map(h => new Hook(h));
          
          if (data.stats && myId) {
            const myStats = data.stats.find(s => s[0] === myId);
            if (myStats) {
              state.myStats.kills = myStats[1];
              state.myStats.deaths = myStats[2];
            }
          }
          
          // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–π–º–µ—Ä –µ—Å–ª–∏ –µ—Å—Ç—å
          if (data.matchTime !== undefined) {
            matchState.remaining = data.matchTime;
          }
          
          updateLeaderboard(data.players);
          break;
          
        case 'event':
          if (data.event.type === 'hookFire' && data.event.playerId === myId) {
            startHookCooldown();
            playHookSound();
          }
          if (data.event.type === 'hookHit') {
            const target = state.players.get(data.event.targetId);
            if (target) {
              createHitEffect(target.x, target.y, '#e74c3c');
              playHitSound();
              if (target.id === myId) {
                showNotification('HIT!', 'notify-hit');
              }
            }
          }
          if (data.event.type === 'playerKill') {
            const victim = state.players.get(data.event.victimId);
            if (victim) {
              createDeathEffect(victim.x, victim.y);
              playKillSound();
              if (data.event.killerId === myId) {
                state.gold += 150;
                showNotification('KILL! +150üí∞', 'notify-kill');
              }
              if (data.event.assistIds?.includes(myId)) {
                state.gold += 50;
                showNotification('ASSIST! +50üí∞', 'notify-save');
              }
            }
          }
          if (data.event.type === 'allySaved') {
            const ally = state.players.get(data.event.allyId);
            if (ally && ally.team === myTeam) {
              createHitEffect(ally.x, ally.y, '#2ecc71');
              playSaveSound();
              showNotification('SAVE!', 'notify-save');
            }
          }
          if (data.event.type === 'matchEnd') {
            const victory = data.event.winner === myTeam;
            showGameOver(victory, data.event.radiantKills, data.event.direKills);
          }
          break;
      }
    }

    function startHookCooldown() {
      hookCooldownState.onCooldown = true;
      hookCooldownState.cooldownEnd = Date.now() + CONFIG.HOOK_COOLDOWN;
      
      const indicator = document.getElementById('hookIndicator');
      const bar = document.getElementById('hookCooldownBar');
      
      indicator.textContent = '‚è≥ COOLDOWN...';
      indicator.className = 'cooldown';
      bar.style.display = 'block';
    }
    
    function updateHookCooldown() {
      const now = Date.now();
      const indicator = document.getElementById('hookIndicator');
      const bar = document.getElementById('hookCooldownBar');
      const fill = document.getElementById('hookCooldownFill');
      
      if (hookCooldownState.onCooldown) {
        const remaining = hookCooldownState.cooldownEnd - now;
        
        if (remaining <= 0) {
          hookCooldownState.onCooldown = false;
          indicator.textContent = 'ü™ù HOOK READY';
          indicator.className = 'ready';
          bar.style.display = 'none';
          fill.style.width = '100%';
        } else {
          const percent = (remaining / CONFIG.HOOK_COOLDOWN) * 100;
          fill.style.width = percent + '%';
        }
      }
    }

    function sendInput() {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      let dx = 0, dy = 0;
      if (input.keys['KeyW']) dy -= 1;
      if (input.keys['KeyS']) dy += 1;
      if (input.keys['KeyA']) dx -= 1;
      if (input.keys['KeyD']) dx += 1;

      if (dx !== 0 || dy !== 0) {
        const len = Math.hypot(dx, dy);
        dx /= len;
        dy /= len;
      }

      ws.send(JSON.stringify({ type: 'move', dx, dy }));

      if (input.hookRequested) {
        const angle = Math.atan2(input.mouseY - canvas.height/2, input.mouseX - canvas.width/2);
        ws.send(JSON.stringify({ type: 'hook', angle }));
        input.hookRequested = false;
      }
    }

    // ==========================================
    // –ö–ê–ú–ï–†–ê
    // ==========================================
    function updateCamera() {
      const player = state.players.get(myId);
      if (!player) return { x: 0, y: 0 };
      
      return {
        x: player.x - canvas.width / 2,
        y: player.y - canvas.height / 2
      };
    }

    // ==========================================
    // –û–¢–†–ò–°–û–í–ö–ê
    // ==========================================
    function drawMap(cameraX, cameraY) {
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      const gridSize = 100;
      const offsetX = -cameraX % gridSize;
      const offsetY = -cameraY % gridSize;

      for (let x = offsetX; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = offsetY; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // –†–µ–∫–∞ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
      const riverScreenY = CONFIG.RIVER_Y - cameraY;
      const riverGradient = ctx.createLinearGradient(0, riverScreenY - CONFIG.RIVER_WIDTH/2, 0, riverScreenY + CONFIG.RIVER_WIDTH/2);
      riverGradient.addColorStop(0, 'rgba(52,152,219,0.2)');
      riverGradient.addColorStop(0.5, 'rgba(52,152,219,0.4)');
      riverGradient.addColorStop(1, 'rgba(52,152,219,0.2)');
      ctx.fillStyle = riverGradient;
      ctx.fillRect(0, riverScreenY - CONFIG.RIVER_WIDTH/2, canvas.width, CONFIG.RIVER_WIDTH);
      
      // –ê–Ω–∏–º–∞—Ü–∏—è –≤–æ–ª–Ω
      const time = Date.now() / 1000;
      ctx.strokeStyle = 'rgba(100,200,255,0.3)';
      ctx.lineWidth = 2;
      for (let i = 0; i < 5; i++) {
        const waveY = riverScreenY - CONFIG.RIVER_WIDTH/4 + i * (CONFIG.RIVER_WIDTH / 4);
        ctx.beginPath();
        for (let x = 0; x < canvas.width; x += 20) {
          const waveX = x + Math.sin(time * 2 + i) * 10;
          if (x === 0) ctx.moveTo(waveX, waveY);
          else ctx.lineTo(waveX, waveY);
        }
        ctx.stroke();
      }

      ctx.strokeStyle = 'rgba(52,152,219,0.6)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, riverScreenY - CONFIG.RIVER_WIDTH/2);
      ctx.lineTo(canvas.width, riverScreenY - CONFIG.RIVER_WIDTH/2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, riverScreenY + CONFIG.RIVER_WIDTH/2);
      ctx.lineTo(canvas.width, riverScreenY + CONFIG.RIVER_WIDTH/2);
      ctx.stroke();

      ctx.strokeStyle = '#e74c3c';
      ctx.lineWidth = 3;
      ctx.strokeRect(-cameraX, -cameraY, CONFIG.FIELD_SIZE, CONFIG.FIELD_SIZE);
    }

    const mmCanvas = document.getElementById('minimap');
    const mmCtx = mmCanvas.getContext('2d');
    const MM_SCALE = 150 / CONFIG.FIELD_SIZE;
    
    function drawMinimap() {
      mmCtx.fillStyle = 'rgba(0,0,0,0.9)';
      mmCtx.fillRect(0, 0, 150, 150);
      
      mmCtx.fillStyle = 'rgba(52,152,219,0.5)';
      mmCtx.fillRect(0, (CONFIG.RIVER_Y - CONFIG.RIVER_WIDTH/2) * MM_SCALE, 150, CONFIG.RIVER_WIDTH * MM_SCALE);
      
      for (const player of state.players.values()) {
        mmCtx.fillStyle = player.team === CONFIG.TEAM_RADIANT ? '#2ecc71' : '#e74c3c';
        const size = player.id === myId ? 5 : 3;
        mmCtx.beginPath();
        mmCtx.arc(player.x * MM_SCALE, player.y * MM_SCALE, size, 0, Math.PI * 2);
        mmCtx.fill();
      }
      
      const player = state.players.get(myId);
      if (player) {
        const camX = player.x - canvas.width / 2;
        const camY = player.y - canvas.height / 2;
        mmCtx.strokeStyle = '#fff';
        mmCtx.lineWidth = 1;
        mmCtx.strokeRect(camX * MM_SCALE, camY * MM_SCALE, canvas.width * MM_SCALE, canvas.height * MM_SCALE);
      }
    }
    
    function updateAndDrawParticles(cameraX, cameraY) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update();
        p.draw(ctx, cameraX, cameraY);
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    
    function showNotification(text, className) {
      const existing = document.getElementById('notification');
      if (existing) existing.remove();
      
      const el = document.createElement('div');
      el.id = 'notification';
      el.className = className;
      el.textContent = text;
      document.body.appendChild(el);
      
      setTimeout(() => el.remove(), 500);
    }
    
    function drawNotifications() {}

    function draw() {
      const camera = updateCamera();
      drawMap(camera.x, camera.y);
      updateAndDrawParticles(camera.x, camera.y);

      for (const hook of state.hooks) {
        hook.draw(ctx, camera.x, camera.y);
      }

      for (const player of state.players.values()) {
        player.update(16);
        player.draw(ctx, camera.x, camera.y);
      }
      
      drawMinimap();
      updateEnemyArrows(camera.x, camera.y);
      updateUI();
      drawNotifications();
    }

    function updateUI() {
      const player = state.players.get(myId);
      if (player) {
        document.getElementById('health').textContent = Math.round(player.health);
        
        // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∏–∑–∫–æ–≥–æ –∑–¥–æ—Ä–æ–≤—å—è
        const hpPercent = player.health / player.maxHealth;
        if (hpPercent < 0.25) {
          document.getElementById('health').style.color = '#f00';
          document.getElementById('health').style.animation = 'timerPulse 0.5s infinite';
        } else {
          document.getElementById('health').style.color = '#e74c3c';
          document.getElementById('health').style.animation = '';
        }
      }
      document.getElementById('kills').textContent = state.myStats.kills;
      document.getElementById('deaths').textContent = state.myStats.deaths;
      document.getElementById('gold').textContent = state.gold;
      updateHookCooldown();
      updateMatchTimer();
    }
    
    function updateMatchTimer() {
      const minutes = Math.floor(matchState.remaining / 60000);
      const seconds = Math.floor((matchState.remaining % 60000) / 1000);
      const timerEl = document.getElementById('matchTimer');
      timerEl.textContent = `‚è±Ô∏è ${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      // –ú–∏–≥–∞–Ω–∏–µ –∫–æ–≥–¥–∞ –æ—Å—Ç–∞–ª–æ—Å—å –º–µ–Ω—å—à–µ 1 –º–∏–Ω—É—Ç—ã
      if (matchState.remaining < 60000) {
        timerEl.classList.add('urgent');
      } else {
        timerEl.classList.remove('urgent');
      }
    }
    
    function showGameOver(victory, radiantKills, direKills) {
      const screen = document.getElementById('gameOverScreen');
      const title = document.getElementById('gameOverTitle');
      const score = document.getElementById('finalScore');
      
      screen.classList.add('show');
      screen.className = victory ? 'victory' : 'defeat';
      title.textContent = victory ? 'üèÜ VICTORY!' : 'üíÄ DEFEAT';
      score.textContent = `Radiant: ${radiantKills} - Dire: ${direKills}`;
      
      playKillSound();
    }

    // ==========================================
    // –ò–ì–†–û–í–û–ô –¶–ò–ö–õ
    // ==========================================
    function gameLoop(timestamp) {
      const dt = timestamp - lastTime;
      lastTime = timestamp;

      if (gameRunning) {
        sendInput();
        draw();
      }

      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
