<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pudge Wars - Hook Battle</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #1a1a2e; font-family: 'Segoe UI', sans-serif; }
    canvas { display: block; }
    
    /* –ë–∞–∑–æ–≤—ã–π UI */
    #ui { position: fixed; top: 10px; left: 10px; color: #fff; z-index: 100; pointer-events: none; }
    #ui h1 { font-size: 24px; color: #e74c3c; text-shadow: 0 0 10px rgba(231,76,60,0.5); margin-bottom: 5px; }
    #ui p { font-size: 12px; color: #888; }
    
    #stats { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px 15px; border-radius: 8px; color: #fff; z-index: 100; }
    #stats div { margin: 3px 0; font-size: 13px; }
    .stat-label { color: #888; }
    .stat-value { color: #e74c3c; font-weight: bold; }
    
    #hookIndicator { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 8px 20px; border-radius: 20px; color: #fff; font-size: 14px; z-index: 100; transition: all 0.2s; }
    #hookIndicator.ready { border: 2px solid #2ecc71; box-shadow: 0 0 10px rgba(46,204,113,0.5); }
    #hookIndicator.cooldown { border: 2px solid #e74c3c; opacity: 0.7; }
    #hookCooldownBar { position: fixed; bottom: 55px; left: 50%; transform: translateX(-50%); width: 150px; height: 6px; background: rgba(0,0,0,0.7); border-radius: 3px; overflow: hidden; z-index: 100; display: none; }
    #hookCooldownFill { height: 100%; background: linear-gradient(90deg, #e74c3c, #f39c12); width: 100%; transition: width 0.05s linear; }
    
    #startScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
    #startScreen.hidden { display: none; }
    #startScreen h1 { font-size: 48px; color: #e74c3c; margin-bottom: 20px; text-shadow: 0 0 30px rgba(231,76,60,0.6); }
    #startScreen p { color: #aaa; margin-bottom: 30px; font-size: 14px; }
    #startBtn { padding: 15px 40px; font-size: 18px; font-weight: bold; color: #fff; background: linear-gradient(135deg, #e74c3c, #c0392b); border: none; border-radius: 8px; cursor: pointer; text-transform: uppercase; }
    #startBtn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(231,76,60,0.5); }
    
    #controls { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px; color: #888; font-size: 11px; z-index: 100; }
    #controls kbd { background: #333; padding: 2px 6px; border-radius: 3px; color: #fff; }
    
    /* –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è */
    #notification { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 48px; font-weight: bold; text-align: center; z-index: 1000; pointer-events: none; text-shadow: 0 0 30px rgba(0,0,0,0.8); animation: notifyPop 0.5s ease-out forwards; }
    @keyframes notifyPop { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 0; } }
    .notify-hit { color: #e74c3c; }
    .notify-kill { color: #f39c12; }
    .notify-death { color: #8e44ad; }
    .notify-save { color: #2ecc71; }
    
    /* –ú–∏–Ω–∏–∫–∞—Ä—Ç–∞ */
    #minimap { position: fixed; top: 10px; right: 10px; width: 150px; height: 150px; background: rgba(0,0,0,0.8); border: 2px solid #444; border-radius: 8px; z-index: 100; }
    
    /* –ó–≤—É–∫ */
    #soundToggle { position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); border: 2px solid #444; border-radius: 8px; padding: 8px 12px; color: #fff; cursor: pointer; z-index: 100; font-size: 18px; }
    #soundToggle:hover { border-color: #e74c3c; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <canvas id="minimap" width="150" height="150"></canvas>
  
  <button id="soundToggle">üîä</button>
  
  <div id="ui">
    <h1>ü•© PUDGE WARS</h1>
    <p id="connectionStatus">Connecting...</p>
  </div>
  
  <div id="stats">
    <div><span class="stat-label">Kills:</span> <span class="stat-value" id="kills">0</span></div>
    <div><span class="stat-label">Deaths:</span> <span class="stat-value" id="deaths">0</span></div>
    <div><span class="stat-label">Health:</span> <span class="stat-value" id="health">1000</span></div>
  </div>
  
  <div id="hookIndicator" class="ready">ü™ù HOOK READY</div>
  <div id="hookCooldownBar"><div id="hookCooldownFill"></div></div>
  
  <div id="controls">
    <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move &nbsp;|&nbsp; <kbd>MOUSE</kbd> Aim &nbsp;|&nbsp; <kbd>CLICK</kbd> Hook
  </div>
  
  <div id="startScreen">
    <h1>ü•© PUDGE WARS</h1>
    <p>Hook enemies ‚Ä¢ Pull allies ‚Ä¢ Dominate the river</p>
    <button id="startBtn">Start Game</button>
  </div>

  <script>
    // ==========================================
    // –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò –ö–û–ù–°–¢–ê–ù–¢–´
    // ==========================================
    const CONFIG = {
      FIELD_SIZE: 2000,
      RIVER_Y: 1000,
      RIVER_WIDTH: 150,
      PLAYER_RADIUS: 18,
      PLAYER_SPEED: 4,
      PLAYER_HEALTH: 1000,
      HOOK_RANGE: 400,
      HOOK_SPEED: 15,
      HOOK_RADIUS: 6,
      HOOK_COOLDOWN: 3000,
      HOOK_DAMAGE: 300,
      HOOK_PULL_SPEED: 8,
      TEAM_RADIANT: 'radiant',
      TEAM_DIRE: 'dire'
    };

    // ==========================================
    // –°–ò–°–¢–ï–ú–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï
    // ==========================================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    let ws = null;
    let myId = null;
    let gameRunning = false;
    let lastTime = 0;
    
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
    const state = {
      players: new Map(),
      hooks: [],
      myTeam: null,
      myStats: { kills: 0, deaths: 0 }
    };
    
    // –í–≤–æ–¥
    const input = {
      keys: {},
      mouseX: 0,
      mouseY: 0,
      hookRequested: false
    };
    
    // –ö—É–ª–¥–∞—É–Ω —Ö—É–∫–∞
    const hookCooldownState = {
      onCooldown: false,
      cooldownEnd: 0
    };
    
    // –°–∏—Å—Ç–µ–º–∞ —á–∞—Å—Ç–∏—Ü
    const particles = [];
    
    // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    const notifications = [];
    
    // –ê—É–¥–∏–æ—Å–∏—Å—Ç–µ–º–∞
    let audioEnabled = true;
    let audioCtx = null;
    
    /**
     * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—É–¥–∏–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
     */
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
    }
    
    /**
     * –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Ç–æ–Ω–∞ (—Å–∏–Ω—Ç–µ–∑–∞—Ç–æ—Ä)
     */
    function playSound(freq, type, duration, volume = 0.1) {
      if (!audioEnabled || !audioCtx) return;
      
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      
      osc.type = type;
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
      
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }
    
    /**
     * –ó–≤—É–∫ –≤—ã—Å—Ç—Ä–µ–ª–∞ –∫—Ä—é–∫–æ–º
     */
    function playHookSound() {
      playSound(400, 'sawtooth', 0.2, 0.15);
    }
    
    /**
     * –ó–≤—É–∫ –ø–æ–ø–∞–¥–∞–Ω–∏—è
     */
    function playHitSound() {
      playSound(200, 'square', 0.15, 0.2);
    }
    
    /**
     * –ó–≤—É–∫ —É–±–∏–π—Å—Ç–≤–∞
     */
    function playKillSound() {
      playSound(300, 'sawtooth', 0.1, 0.15);
      setTimeout(() => playSound(400, 'sawtooth', 0.2, 0.15), 100);
    }
    
    /**
     * –ó–≤—É–∫ —Å–º–µ—Ä—Ç–∏
     */
    function playDeathSound() {
      playSound(200, 'sawtooth', 0.3, 0.2);
      setTimeout(() => playSound(150, 'sawtooth', 0.4, 0.2), 150);
    }
    
    /**
     * –ó–≤—É–∫ —Å–ø–∞—Å–µ–Ω–∏—è
     */
    function playSaveSound() {
      playSound(500, 'sine', 0.15, 0.1);
      setTimeout(() => playSound(700, 'sine', 0.2, 0.1), 100);
    }

    // ==========================================
    // –ö–õ–ê–°–°–´
    // ==========================================
    
    /**
     * –ß–∞—Å—Ç–∏—Ü–∞ –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
     */
    class Particle {
      constructor(x, y, color, speed, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = speed * (0.5 + Math.random() * 0.5);
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
        this.life = life;
        this.maxLife = life;
        this.size = 3 + Math.random() * 3;
      }
      
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.life--;
      }
      
      draw(ctx, cameraX, cameraY) {
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x - cameraX, this.y - cameraY, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
    
    /**
     * –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è –∫—Ä—é–∫–∞
     */
    function createHitEffect(x, y, color) {
      for (let i = 0; i < 15; i++) {
        particles.push(new Particle(x, y, color, 5, 30));
      }
    }
    
    /**
     * –≠—Ñ—Ñ–µ–∫—Ç —Å–º–µ—Ä—Ç–∏
     */
    function createDeathEffect(x, y) {
      for (let i = 0; i < 30; i++) {
        particles.push(new Particle(x, y, '#8e44ad', 8, 50));
        particles.push(new Particle(x, y, '#e74c3c', 6, 40));
      }
    }
    
    /**
     * –ò–≥—Ä–æ–∫ (Pudge)
     */
    class Player {
      constructor(data) {
        this.id = data[0];
        this.x = data[1];
        this.y = data[2];
        this.team = data[3];
        this.health = data[4];
        this.maxHealth = data[5];
        this.angle = 0;
        this.isDead = false;
      }
      
      update(dt) {
        // –ü–ª–∞–≤–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç –∫ –ø–æ–∑–∏—Ü–∏–∏
        if (this.id === myId) {
          const targetAngle = Math.atan2(input.mouseY - canvas.height/2, input.mouseX - canvas.width/2);
          this.angle = targetAngle;
        }
      }
      
      draw(ctx, cameraX, cameraY) {
        const screenX = this.x - cameraX;
        const screenY = this.y - cameraY;

        // –°–≤–µ—á–µ–Ω–∏–µ –¥–ª—è —Å–≤–æ–µ–≥–æ –∏–≥—Ä–æ–∫–∞
        if (this.id === myId) {
          const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, CONFIG.PLAYER_RADIUS * 2);
          gradient.addColorStop(0, 'rgba(241, 196, 15, 0.3)');
          gradient.addColorStop(1, 'rgba(241, 196, 15, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(screenX, screenY, CONFIG.PLAYER_RADIUS * 2, 0, Math.PI * 2);
          ctx.fill();
        }

        // –¢–µ–ª–æ
        ctx.beginPath();
        ctx.arc(screenX, screenY, CONFIG.PLAYER_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = this.team === CONFIG.TEAM_RADIANT ? '#2ecc71' : '#e74c3c';
        ctx.fill();
        
        // –û–±–≤–æ–¥–∫–∞
        ctx.lineWidth = 3;
        ctx.strokeStyle = this.id === myId ? '#f1c40f' : '#333';
        ctx.stroke();
        
        // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫—Ä—É–≥ –¥–ª—è –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏
        ctx.beginPath();
        ctx.arc(screenX, screenY, CONFIG.PLAYER_RADIUS * 0.6, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fill();

        // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∑–≥–ª—è–¥–∞
        ctx.beginPath();
        ctx.moveTo(screenX, screenY);
        ctx.lineTo(
          screenX + Math.cos(this.angle) * CONFIG.PLAYER_RADIUS * 1.5,
          screenY + Math.sin(this.angle) * CONFIG.PLAYER_RADIUS * 1.5
        );
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∞–¥ –≥–æ–ª–æ–≤–æ–π –¥–ª—è —Å–≤–æ–µ–≥–æ –∏–≥—Ä–æ–∫–∞
        if (this.id === myId) {
          ctx.fillStyle = '#f1c40f';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('YOU', screenX, screenY - CONFIG.PLAYER_RADIUS - 8);
        }

        // –ü–æ–ª–æ—Å–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è
        const hpBarWidth = 40;
        const hpPercent = this.health / this.maxHealth;
        ctx.fillStyle = '#333';
        ctx.fillRect(screenX - hpBarWidth/2, screenY + CONFIG.PLAYER_RADIUS + 5, hpBarWidth, 4);
        ctx.fillStyle = hpPercent > 0.5 ? '#2ecc71' : hpPercent > 0.25 ? '#f39c12' : '#e74c3c';
        ctx.fillRect(screenX - hpBarWidth/2, screenY + CONFIG.PLAYER_RADIUS + 5, hpBarWidth * hpPercent, 4);
      }
    }
    
    /**
     * –ö—Ä—é–∫ (Meat Hook)
     */
    class Hook {
      constructor(data) {
        this.id = data[0];
        this.x = data[1];
        this.y = data[2];
        this.targetX = data[3];
        this.targetY = data[4];
        this.ownerId = data[5];
        this.state = 'flying'; // flying, returning, pulling
        this.targetId = null;
        this.trail = []; // –°–ª–µ–¥ –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞

        // –í—ã—á–∏—Å–ª—è–µ–º –≤–µ–∫—Ç–æ—Ä –¥–≤–∏–∂–µ–Ω–∏—è
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        const dist = Math.hypot(dx, dy);
        this.vx = (dx / dist) * CONFIG.HOOK_SPEED;
        this.vy = (dy / dist) * CONFIG.HOOK_SPEED;
        this.traveled = 0;
      }

      update(dt) {
        // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –≤ —Å–ª–µ–¥
        if (this.state === 'flying') {
          this.trail.push({ x: this.x, y: this.y, life: 10 });
        }
      
        if (this.state === 'flying') {
          this.x += this.vx;
          this.y += this.vy;
          this.traveled += CONFIG.HOOK_SPEED;

          // –î–æ—Å—Ç–∏–≥ –º–∞–∫—Å–∏–º—É–º–∞ - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è
          if (this.traveled >= CONFIG.HOOK_RANGE) {
            this.state = 'returning';
          }
        } else if (this.state === 'returning' || this.state === 'pulling') {
          const owner = state.players.get(this.ownerId);
          if (owner) {
            const dx = owner.x - this.x;
            const dy = owner.y - this.y;
            const dist = Math.hypot(dx, dy);

            if (dist < 10) {
              this.state = 'done';
            } else {
              this.x += (dx / dist) * CONFIG.HOOK_PULL_SPEED;
              this.y += (dy / dist) * CONFIG.HOOK_PULL_SPEED;

              // –ï—Å–ª–∏ —Ç–∞—â–∏–º —Ü–µ–ª—å
              if (this.state === 'pulling' && this.targetId !== null) {
                const target = state.players.get(this.targetId);
                if (target) {
                  target.x = this.x;
                  target.y = this.y;
                }
              }
            }
          } else {
            this.state = 'done';
          }
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–µ–¥
        for (let i = this.trail.length - 1; i >= 0; i--) {
          this.trail[i].life--;
          if (this.trail[i].life <= 0) {
            this.trail.splice(i, 1);
          }
        }
      }

      draw(ctx, cameraX, cameraY) {
        const screenX = this.x - cameraX;
        const screenY = this.y - cameraY;
        const owner = state.players.get(this.ownerId);

        if (!owner) return;

        const ownerScreenX = owner.x - cameraX;
        const ownerScreenY = owner.y - cameraY;
        
        // –†–∏—Å—É–µ–º —Å–ª–µ–¥
        for (const point of this.trail) {
          const alpha = point.life / 10;
          ctx.globalAlpha = alpha;
          ctx.fillStyle = '#e74c3c';
          ctx.beginPath();
          ctx.arc(point.x - cameraX, point.y - cameraY, CONFIG.HOOK_RADIUS * 0.7, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        // –¶–µ–ø—å/–≤–µ—Ä–µ–≤–∫–∞
        ctx.beginPath();
        ctx.moveTo(ownerScreenX, ownerScreenY);
        ctx.lineTo(screenX, screenY);
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);

        // –°–∞–º –∫—Ä—é–∫
        ctx.beginPath();
        ctx.arc(screenX, screenY, CONFIG.HOOK_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = this.state === 'pulling' ? '#f39c12' : '#e74c3c';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // –ë–ª–µ—Å–∫ –Ω–∞ –∫—Ä—é–∫–µ
        ctx.beginPath();
        ctx.arc(screenX - 2, screenY - 2, CONFIG.HOOK_RADIUS * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fill();
      }
    }

    // ==========================================
    // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
    // ==========================================
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ==========================================
    // –£–ü–†–ê–í–õ–ï–ù–ò–ï
    // ==========================================
    document.addEventListener('keydown', (e) => {
      input.keys[e.code] = true;
    });
    
    document.addEventListener('keyup', (e) => {
      input.keys[e.code] = false;
    });
    
    document.addEventListener('mousemove', (e) => {
      input.mouseX = e.clientX;
      input.mouseY = e.clientY;
    });
    
    document.addEventListener('mousedown', (e) => {
      if (e.button === 0 && gameRunning) {
        input.hookRequested = true;
      }
    });
    
    document.getElementById('startBtn').addEventListener('click', () => {
      document.getElementById('startScreen').classList.add('hidden');
      gameRunning = true;
      initAudio(); // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—É–¥–∏–æ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∫–ª–∏–∫–µ
      connect();
    });
    
    // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –∑–≤—É–∫–∞
    document.getElementById('soundToggle').addEventListener('click', () => {
      audioEnabled = !audioEnabled;
      document.getElementById('soundToggle').textContent = audioEnabled ? 'üîä' : 'üîá';
    });

    // ==========================================
    // –°–ï–¢–ï–í–û–ï –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–ï
    // ==========================================
    function connect() {
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${location.host}`);
      
      ws.onopen = () => {
        document.getElementById('connectionStatus').textContent = 'Connected';
        document.getElementById('connectionStatus').style.color = '#2ecc71';
      };
      
      ws.onmessage = (e) => {
        const data = JSON.parse(e.data);
        handleServerMessage(data);
      };
      
      ws.onclose = () => {
        document.getElementById('connectionStatus').textContent = 'Disconnected';
        document.getElementById('connectionStatus').style.color = '#e74c3c';
        gameRunning = false;
      };
    }
    
    function handleServerMessage(data) {
      switch(data.type) {
        case 'welcome':
          myId = data.playerId;
          myTeam = data.team;
          state.myTeam = data.team;
          // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä–æ–∫–æ–≤
          for (const p of data.players) {
            state.players.set(p[0], new Player(p));
          }
          break;
          
        case 'state':
          // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä–æ–∫–æ–≤
          const newPlayers = new Map();
          for (const p of data.players) {
            const existing = state.players.get(p[0]);
            if (existing) {
              existing.x = p[1];
              existing.y = p[2];
              existing.team = p[3];
              existing.health = p[4];
              existing.maxHealth = p[5];
              newPlayers.set(p[0], existing);
            } else {
              newPlayers.set(p[0], new Player(p));
            }
          }
          state.players = newPlayers;
          
          // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—Ä—é–∫–æ–≤
          state.hooks = data.hooks.map(h => new Hook(h));
          
          // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
          if (data.stats && myId) {
            const myStats = data.stats.find(s => s[0] === myId);
            if (myStats) {
              state.myStats.kills = myStats[1];
              state.myStats.deaths = myStats[2];
            }
          }
          break;
          
        case 'event':
          // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π
          if (data.event.type === 'hookFire' && data.event.playerId === myId) {
            startHookCooldown();
            playHookSound();
          }
          // –ü–æ–ø–∞–¥–∞–Ω–∏–µ —Ö—É–∫–∞
          if (data.event.type === 'hookHit') {
            const target = state.players.get(data.event.targetId);
            if (target) {
              createHitEffect(target.x, target.y, '#e74c3c');
              playHitSound();
              // –ï—Å–ª–∏ –ø–æ–ø–∞–ª–∏ –≤ –º–µ–Ω—è
              if (target.id === myId) {
                showNotification('HIT!', 'notify-hit');
              }
            }
          }
          // –£–±–∏–π—Å—Ç–≤–æ
          if (data.event.type === 'playerKill') {
            const victim = state.players.get(data.event.victimId);
            if (victim) {
              createDeathEffect(victim.x, victim.y);
              playKillSound();
              if (data.event.killerId === myId) {
                showNotification('KILL!', 'notify-kill');
              }
            }
          }
          // –°–ø–∞—Å–µ–Ω–∏–µ —Å–æ—é–∑–Ω–∏–∫–∞
          if (data.event.type === 'allySaved') {
            const ally = state.players.get(data.event.allyId);
            if (ally && ally.team === myTeam) {
              createHitEffect(ally.x, ally.y, '#2ecc71');
              playSaveSound();
              showNotification('SAVE!', 'notify-save');
            }
          }
          break;
      }
    }
    
    /**
     * –ó–∞–ø—É—Å–∫ –∫—É–ª–¥–∞—É–Ω–∞ —Ö—É–∫–∞
     */
    function startHookCooldown() {
      hookCooldownState.onCooldown = true;
      hookCooldownState.cooldownEnd = Date.now() + CONFIG.HOOK_COOLDOWN;
      
      const indicator = document.getElementById('hookIndicator');
      const bar = document.getElementById('hookCooldownBar');
      
      indicator.textContent = '‚è≥ COOLDOWN...';
      indicator.className = 'cooldown';
      bar.style.display = 'block';
    }
    
    /**
     * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫—É–ª–¥–∞—É–Ω–∞
     */
    function updateHookCooldown() {
      const now = Date.now();
      const indicator = document.getElementById('hookIndicator');
      const bar = document.getElementById('hookCooldownBar');
      const fill = document.getElementById('hookCooldownFill');
      
      if (hookCooldownState.onCooldown) {
        const remaining = hookCooldownState.cooldownEnd - now;
        
        if (remaining <= 0) {
          // –ö—É–ª–¥–∞—É–Ω –∑–∞–∫–æ–Ω—á–∏–ª—Å—è
          hookCooldownState.onCooldown = false;
          indicator.textContent = 'ü™ù HOOK READY';
          indicator.className = 'ready';
          bar.style.display = 'none';
          fill.style.width = '100%';
        } else {
          // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–æ—Å–∫—É
          const percent = (remaining / CONFIG.HOOK_COOLDOWN) * 100;
          fill.style.width = percent + '%';
        }
      }
    }
    
    function sendInput() {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      
      // –î–≤–∏–∂–µ–Ω–∏–µ
      let dx = 0, dy = 0;
      if (input.keys['KeyW']) dy -= 1;
      if (input.keys['KeyS']) dy += 1;
      if (input.keys['KeyA']) dx -= 1;
      if (input.keys['KeyD']) dx += 1;
      
      // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –¥–∏–∞–≥–æ–Ω–∞–ª–µ–π
      if (dx !== 0 || dy !== 0) {
        const len = Math.hypot(dx, dy);
        dx /= len;
        dy /= len;
      }
      
      ws.send(JSON.stringify({
        type: 'move',
        dx, dy
      }));
      
      // –í—ã—Å—Ç—Ä–µ–ª –∫—Ä—é–∫–æ–º
      if (input.hookRequested) {
        const angle = Math.atan2(input.mouseY - canvas.height/2, input.mouseX - canvas.width/2);
        ws.send(JSON.stringify({
          type: 'hook',
          angle
        }));
        input.hookRequested = false;
      }
    }

    // ==========================================
    // –ö–ê–ú–ï–†–ê
    // ==========================================
    function updateCamera() {
      const player = state.players.get(myId);
      if (!player) return { x: 0, y: 0 };
      
      // –ö–∞–º–µ—Ä–∞ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞ –Ω–∞ –∏–≥—Ä–æ–∫–µ
      return {
        x: player.x - canvas.width / 2,
        y: player.y - canvas.height / 2
      };
    }

    // ==========================================
    // –û–¢–†–ò–°–û–í–ö–ê
    // ==========================================
    function drawMap(cameraX, cameraY) {
      // –§–æ–Ω
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // –°–µ—Ç–∫–∞
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      const gridSize = 100;
      const offsetX = -cameraX % gridSize;
      const offsetY = -cameraY % gridSize;
      
      for (let x = offsetX; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = offsetY; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
      
      // –†–µ–∫–∞
      const riverScreenY = CONFIG.RIVER_Y - cameraY;
      ctx.fillStyle = 'rgba(52,152,219,0.3)';
      ctx.fillRect(0, riverScreenY - CONFIG.RIVER_WIDTH/2, canvas.width, CONFIG.RIVER_WIDTH);
      
      // –ì—Ä–∞–Ω–∏—Ü—ã —Ä–µ–∫–∏
      ctx.strokeStyle = 'rgba(52,152,219,0.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, riverScreenY - CONFIG.RIVER_WIDTH/2);
      ctx.lineTo(canvas.width, riverScreenY - CONFIG.RIVER_WIDTH/2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, riverScreenY + CONFIG.RIVER_WIDTH/2);
      ctx.lineTo(canvas.width, riverScreenY + CONFIG.RIVER_WIDTH/2);
      ctx.stroke();
      
      // –ì—Ä–∞–Ω–∏—Ü—ã –∫–∞—Ä—Ç—ã
      ctx.strokeStyle = '#e74c3c';
      ctx.lineWidth = 3;
      ctx.strokeRect(-cameraX, -cameraY, CONFIG.FIELD_SIZE, CONFIG.FIELD_SIZE);
    }
    
    function draw() {
      const camera = updateCamera();

      drawMap(camera.x, camera.y);
      
      // –†–∏—Å—É–µ–º —á–∞—Å—Ç–∏—Ü—ã
      updateAndDrawParticles(camera.x, camera.y);

      // –†–∏—Å—É–µ–º –∫—Ä—é–∫–∏
      for (const hook of state.hooks) {
        hook.draw(ctx, camera.x, camera.y);
      }

      // –†–∏—Å—É–µ–º –∏–≥—Ä–æ–∫–æ–≤
      for (const player of state.players.values()) {
        player.update(16);
        player.draw(ctx, camera.x, camera.y);
      }
      
      // –†–∏—Å—É–µ–º –º–∏–Ω–∏–∫–∞—Ä—Ç—É
      drawMinimap();

      // –û–±–Ω–æ–≤–ª—è–µ–º UI
      updateUI();
      
      // –†–∏—Å—É–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
      drawNotifications();
    }
    
    /**
     * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ —á–∞—Å—Ç–∏—Ü
     */
    function updateAndDrawParticles(cameraX, cameraY) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update();
        p.draw(ctx, cameraX, cameraY);
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    
    /**
     * –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –º–∏–Ω–∏–∫–∞—Ä—Ç—ã
     */
    const mmCanvas = document.getElementById('minimap');
    const mmCtx = mmCanvas.getContext('2d');
    const MM_SCALE = 150 / CONFIG.FIELD_SIZE;
    
    function drawMinimap() {
      // –û—á–∏—Å—Ç–∫–∞
      mmCtx.fillStyle = 'rgba(0,0,0,0.9)';
      mmCtx.fillRect(0, 0, 150, 150);
      
      // –†–µ–∫–∞
      mmCtx.fillStyle = 'rgba(52,152,219,0.5)';
      mmCtx.fillRect(0, (CONFIG.RIVER_Y - CONFIG.RIVER_WIDTH/2) * MM_SCALE, 150, CONFIG.RIVER_WIDTH * MM_SCALE);
      
      // –ò–≥—Ä–æ–∫–∏
      for (const player of state.players.values()) {
        mmCtx.fillStyle = player.team === CONFIG.TEAM_RADIANT ? '#2ecc71' : '#e74c3c';
        const size = player.id === myId ? 5 : 3;
        mmCtx.beginPath();
        mmCtx.arc(
          player.x * MM_SCALE,
          player.y * MM_SCALE,
          size, 0, Math.PI * 2
        );
        mmCtx.fill();
      }
      
      // –†–∞–º–∫–∞ –∫–∞–º–µ—Ä—ã
      const player = state.players.get(myId);
      if (player) {
        const camX = player.x - canvas.width / 2;
        const camY = player.y - canvas.height / 2;
        mmCtx.strokeStyle = '#fff';
        mmCtx.lineWidth = 1;
        mmCtx.strokeRect(
          camX * MM_SCALE,
          camY * MM_SCALE,
          canvas.width * MM_SCALE,
          canvas.height * MM_SCALE
        );
      }
    }
    
    function updateUI() {
      const player = state.players.get(myId);
      if (player) {
        document.getElementById('health').textContent = Math.round(player.health);
      }
      document.getElementById('kills').textContent = state.myStats.kills;
      document.getElementById('deaths').textContent = state.myStats.deaths;
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –∫—É–ª–¥–∞—É–Ω —Ö—É–∫–∞
      updateHookCooldown();
    }
    
    /**
     * –°–æ–∑–¥–∞–Ω–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –Ω–∞ —ç–∫—Ä–∞–Ω–µ
     */
    function showNotification(text, className) {
      const existing = document.getElementById('notification');
      if (existing) existing.remove();
      
      const el = document.createElement('div');
      el.id = 'notification';
      el.className = className;
      el.textContent = text;
      document.body.appendChild(el);
      
      setTimeout(() => el.remove(), 500);
    }
    
    /**
     * –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π (–¥–ª—è –±—É–¥—É—â–∏—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤)
     */
    function drawNotifications() {
      // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
    }

    // ==========================================
    // –ò–ì–†–û–í–û–ô –¶–ò–ö–õ
    // ==========================================
    function gameLoop(timestamp) {
      const dt = timestamp - lastTime;
      lastTime = timestamp;
      
      if (gameRunning) {
        sendInput();
        draw();
      }
      
      requestAnimationFrame(gameLoop);
    }
    
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
