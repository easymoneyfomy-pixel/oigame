<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parasite Arena</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #0a0a16; }
    canvas { display: block; }
    
    #ui {
      position: fixed;
      top: 15px;
      left: 15px;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      font-size: 13px;
      background: linear-gradient(135deg, rgba(20,20,40,0.95), rgba(10,10,25,0.98));
      padding: 18px 22px;
      border-radius: 14px;
      z-index: 100;
      user-select: none;
      border: 1px solid rgba(100,150,255,0.25);
      box-shadow: 0 8px 32px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.1);
      min-width: 200px;
    }
    #ui strong {
      font-size: 17px;
      background: linear-gradient(90deg, #6af, #4f8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 20px rgba(100,200,255,0.5);
    }
    #ui .divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(100,150,255,0.3), transparent);
      margin: 12px 0;
    }
    #ui .stat { display: flex; justify-content: space-between; margin: 5px 0; }
    #ui .stat-label { color: #88a; }
    #ui .stat-value { font-weight: bold; }
    
    #heatBar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 12px;
      background: rgba(0,0,0,0.6);
      border-radius: 6px;
      overflow: hidden;
      z-index: 100;
      display: none;
      border: 1px solid rgba(255,255,255,0.1);
    }
    #heatFill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #4f8, #ff4, #f44);
      transition: width 0.1s ease;
      box-shadow: 0 0 20px rgba(255,100,100,0.5);
    }
    #heatLabel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 9px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 5px #000;
    }
    
    #exitTimer {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ff6b6b;
      font-family: 'Segoe UI', sans-serif;
      font-size: 36px;
      font-weight: bold;
      text-shadow: 0 0 25px rgba(255,107,107,0.9);
      display: none;
      z-index: 100;
      pointer-events: none;
      animation: pulse 0.4s ease-in-out infinite alternate;
    }
    @keyframes pulse {
      from { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1.08); }
    }
    
    #status {
      position: fixed;
      bottom: 15px;
      left: 15px;
      color: #668;
      font-family: 'Segoe UI', sans-serif;
      font-size: 11px;
      z-index: 100;
      background: rgba(0,0,0,0.5);
      padding: 8px 14px;
      border-radius: 6px;
    }
    
    #globalEvent {
      position: fixed;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 20px;
      font-weight: bold;
      color: #f64;
      text-shadow: 0 0 20px rgba(255,100,50,0.8);
      z-index: 100;
      display: none;
      pointer-events: none;
      animation: eventGlow 2s ease-in-out infinite;
    }
    @keyframes eventGlow {
      0%, 100% { text-shadow: 0 0 20px rgba(255,100,50,0.8); }
      50% { text-shadow: 0 0 40px rgba(255,100,50,1); }
    }
    
    #comboDisplay {
      position: fixed;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 42px;
      font-weight: bold;
      color: #ff0;
      text-shadow: 0 0 30px rgba(255,200,0,0.9);
      z-index: 100;
      display: none;
      pointer-events: none;
    }
    
    .effect-text {
      position: fixed;
      font-size: 24px;
      font-weight: bold;
      pointer-events: none;
      z-index: 200;
      animation: floatUp 1s ease-out forwards;
    }
    @keyframes floatUp {
      0% { opacity: 1; transform: translateY(0) scale(1); }
      100% { opacity: 0; transform: translateY(-50px) scale(1.2); }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  
  <div id="ui">
    <div><strong>ü¶† PARASITE ARENA</strong></div>
    <div class="divider"></div>
    <div style="color:#aaa;font-size:11px;margin-bottom:8px">WASD ‚Äî Move | SPACE ‚Äî Infect</div>
    <div class="stat"><span class="stat-label">üë• Players:</span><span class="stat-value" id="playerCount" style="color:#6ff">0</span></div>
    <div class="stat"><span class="stat-label">üì° Ping:</span><span class="stat-value" id="ping" style="color:#4f4">--</span></div>
    <div class="stat"><span class="stat-label">üî• Heat:</span><span class="stat-value" id="heatValue" style="color:#f64">0%</span></div>
    <div class="stat"><span class="stat-label">üíÄ Infections:</span><span class="stat-value" id="infectCount" style="color:#f44">0</span></div>
  </div>
  
  <div id="heatBar"><div id="heatFill"></div><span id="heatLabel">HEAT</span></div>
  <div id="exitTimer">‚è± FREE IN <span id="timerValue">5.0</span>s</div>
  <div id="globalEvent">‚ö†Ô∏è HEATWAVE</div>
  <div id="comboDisplay">üî• x3 COMBO!</div>
  <div id="status">Disconnected</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const playerCountEl = document.getElementById('playerCount');
    const pingEl = document.getElementById('ping');
    const heatValueEl = document.getElementById('heatValue');
    const infectCountEl = document.getElementById('infectCount');
    const exitTimerEl = document.getElementById('exitTimer');
    const timerValueEl = document.getElementById('timerValue');
    const statusEl = document.getElementById('status');
    const heatBarEl = document.getElementById('heatBar');
    const heatFillEl = document.getElementById('heatFill');
    const globalEventEl = document.getElementById('globalEvent');
    const comboDisplayEl = document.getElementById('comboDisplay');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const WS_URL = `wss://${window.location.host}`;
    const PLAYER_RADIUS = 12;
    const INFECT_DURATION = 5000;
    const FIELD_SIZE = 2500;
    const BOUNDARY_WARNING = 300; // –î–∏—Å—Ç–∞–Ω—Ü–∏—è –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –æ –≥—Ä–∞–Ω–∏—Ü–µ

    const ZONE_STYLES = {
      normal: {
        bg: 'rgba(15,18,35,0.9)',
        border: 'rgba(80,100,140,0.4)',
        grid: 'rgba(70,90,130,0.25)',
        pattern: 'dots'
      },
      safe: {
        bg: 'rgba(30,60,40,0.85)',
        border: 'rgba(80,180,100,0.6)',
        grid: 'rgba(60,140,90,0.3)',
        pattern: 'diagonal',
        glow: 'rgba(60,160,80,0.15)'
      },
      danger: {
        bg: 'rgba(70,25,25,0.85)',
        border: 'rgba(200,80,80,0.7)',
        grid: 'rgba(180,60,60,0.35)',
        pattern: 'stripes',
        glow: 'rgba(180,50,50,0.2)'
      },
      speed: {
        bg: 'rgba(25,35,70,0.85)',
        border: 'rgba(100,140,220,0.6)',
        grid: 'rgba(90,120,200,0.35)',
        pattern: 'arrows',
        glow: 'rgba(80,120,200,0.15)'
      }
    };

    let ws = null;
    let players = new Map();
    let myId = null;
    let zones = [];
    let lastServerTime = 0;
    let gameTime = 0;
    let globalEvent = null;
    let connectionState = 'disconnected';
    let reconnectAttempts = 0;
    let particles = [];
    let floatingTexts = [];
    let screenShake = 0;
    let myStats = { infections: 0, deaths: 0 };
    let bgStars = [];
    let boundaryPulse = 0;

    function initStars() {
      bgStars = [];
      for (let i = 0; i < 200; i++) {
        bgStars.push({
          x: Math.random() * FIELD_SIZE,
          y: Math.random() * FIELD_SIZE,
          size: Math.random() * 1.5 + 0.5,
          alpha: Math.random() * 0.5 + 0.3,
          twinkle: Math.random() * Math.PI * 2
        });
      }
    }
    initStars();

    const keysDown = {};

    document.addEventListener('keydown', (e) => {
      if (['KeyW','KeyA','KeyS','KeyD','Space'].includes(e.code)) e.preventDefault();
      keysDown[e.code] = true;
      if (e.code === 'Space') tryInfect();
    });

    document.addEventListener('keyup', (e) => keysDown[e.code] = false);

    function connect() {
      if (ws) ws.close();
      statusEl.textContent = 'Connecting...';
      statusEl.style.color = '#fa0';
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        connectionState = 'connected';
        statusEl.textContent = 'Connected';
        statusEl.style.color = '#4f4';
        reconnectAttempts = 0;
        createParticles(canvas.width/2, canvas.height/2, 40, '#6af');
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'welcome') myId = data.playerId;
          else if (data.type === 'state') {
            lastServerTime = data.t;
            gameTime = data.gt;
            globalEvent = data.ge;
            updatePlayers(data.p);
          } else if (data.type === 'event') handleEvent(data.event);
          else if (data.type === 'zones') zones = data.zones;
        } catch (e) {}
      };

      ws.onclose = () => {
        connectionState = 'disconnected';
        statusEl.textContent = 'Disconnected';
        statusEl.style.color = '#f44';
        if (reconnectAttempts < 5) { reconnectAttempts++; setTimeout(connect, 2000); }
      };

      ws.onerror = () => {
        statusEl.textContent = 'Error';
        statusEl.style.color = '#f44';
      };
    }

    function handleEvent(event) {
      const myPlayer = getMyPlayer();
      const camX = myPlayer ? myPlayer.displayX - canvas.width/2 : 0;
      const camY = myPlayer ? myPlayer.displayY - canvas.height/2 : 0;

      if (event.type === 'infect') {
        const sx = event.x - camX, sy = event.y - camY;
        createParticles(sx, sy, 50, '#f44');
        createParticles(sx, sy, 25, '#ff0');
        screenShake = event.combo >= 3 ? 15 : 8;
        if (event.target === myId) {
          showFloatingText(canvas.width/2, canvas.height/2, 'INFECTED!', '#f44');
          showFloatingText(canvas.width/2, canvas.height/2 + 40, `by #${event.infector}`, '#fa0');
        }
        if (event.infector === myId) {
          showFloatingText(canvas.width/2, canvas.height/2 - 50, `+1 ${event.combo > 1 ? `COMBO x${event.combo}!` : ''}`, '#6f4');
          myStats.infections++;
          infectCountEl.textContent = myStats.infections;
        }
      } else if (event.type === 'parasiteExit') {
        const sx = event.x - camX, sy = event.y - camY;
        createParticles(sx, sy, 30, '#4f4');
        showFloatingText(sx, sy, 'FREE!', '#4f4');
      } else if (event.type === 'playerJoin') {
        showFloatingText(canvas.width/2, 80, '‚ûï Player joined', '#6af');
      } else if (event.type === 'playerLeave') {
        showFloatingText(canvas.width/2, 80, 'Player left', '#888');
      } else if (event.type === 'combo') {
        showFloatingText(canvas.width/2, 150, `üî• #${event.playerId} on ${event.combo}x COMBO!`, '#ff0');
        screenShake = 10;
      } else if (event.type === 'globalEvent') {
        globalEventEl.textContent = getEventName(event.event);
        globalEventEl.style.display = 'block';
        setTimeout(() => { globalEventEl.style.display = 'none'; }, 3000);
      } else if (event.type === 'zonesRegenerated') {
        zones = event.zones;
        showFloatingText(canvas.width/2, canvas.height/2, 'MAP CHANGED!', '#6af');
        screenShake = 5;
      }
    }

    function getEventName(type) {
      return { heatwave: 'üî• HEATWAVE', darkness: 'üåë DARKNESS', speedfrenzy: '‚ö° SPEED FRENZY' }[type] || type;
    }

    function updatePlayers(playerData) {
      const newPlayers = new Map();
      for (const p of playerData) {
        const [id, x, y, vx, vy, radius, hostId, infectedAt, heat, combo, stunned] = p;
        const existing = players.get(id);
        if (existing) {
          Object.assign(existing, { x, y, vx, vy, radius, hostId, infectedAt, heat, combo, stunned });
          newPlayers.set(id, existing);
        } else {
          newPlayers.set(id, { id, x, y, vx, vy, radius, hostId, infectedAt, heat, combo, stunned,
            displayX: x, displayY: y, pulse: Math.random() * Math.PI * 2 });
        }
      }
      players = newPlayers;
      playerCountEl.textContent = players.size;
    }

    function getMyPlayer() { return players.get(myId); }

    function tryInfect() {
      if (connectionState !== 'connected') return;
      const myPlayer = getMyPlayer();
      if (!myPlayer || myPlayer.hostId !== null) return;
      let closest = null, closestDist = Infinity;
      for (const [id, p] of players) {
        if (id === myPlayer.id || p.hostId !== null) continue;
        const dist = Math.hypot(p.x - myPlayer.x, p.y - myPlayer.y);
        if (dist < closestDist) { closestDist = dist; closest = p; }
      }
      if (closest && closestDist < PLAYER_RADIUS * 3.5) {
        ws.send(JSON.stringify({ type: 'infect', targetId: closest.id }));
      }
    }

    function showFloatingText(x, y, text, color) {
      const el = document.createElement('div');
      el.className = 'effect-text';
      el.textContent = text;
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.style.color = color;
      el.style.textShadow = `0 0 15px ${color}`;
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1000);
    }

    function sendMovement() {
      if (connectionState !== 'connected') return;
      const myPlayer = getMyPlayer();
      if (!myPlayer || myPlayer.hostId !== null || myPlayer.stunned > 0) return;
      let dx = 0, dy = 0;
      if (keysDown['KeyW']) dy = -1;
      if (keysDown['KeyS']) dy = 1;
      if (keysDown['KeyA']) dx = -1;
      if (keysDown['KeyD']) dx = 1;
      if (dx !== 0 || dy !== 0) ws.send(JSON.stringify({ type: 'move', dx, dy }));
    }

    function createParticles(x, y, count, color) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 3;
        particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
          life: 1, decay: Math.random() * 0.02 + 0.01, color, size: Math.random() * 5 + 2 });
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.vx *= 0.95; p.vy *= 0.95;
        p.life -= p.decay;
        if (p.life <= 0) particles.splice(i, 1);
      }
      if (screenShake > 0) screenShake *= 0.9;
      if (screenShake < 0.5) screenShake = 0;
    }

    function drawParticles() {
      for (const p of particles) {
        ctx.save();
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    function lerp(a, b, t) { return a + (b - a) * Math.min(1, t * 0.2); }

    function drawZonePattern(zone, style, time) {
      const { x, y, w, h } = zone;
      if (style.pattern === 'diagonal') {
        ctx.strokeStyle = style.border;
        ctx.lineWidth = 2;
        for (let i = -h; i < w; i += 20) {
          ctx.beginPath(); ctx.moveTo(x + i, y); ctx.lineTo(x + i + h, y + h); ctx.stroke();
        }
      } else if (style.pattern === 'stripes') {
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        for (let i = 0; i < w; i += 15) { ctx.fillRect(x + i, y, 8, h); }
      } else if (style.pattern === 'arrows') {
        ctx.fillStyle = style.border;
        const arrowSpacing = 50;
        const offset = (time * 30) % arrowSpacing;
        for (let i = 0; i < w; i += arrowSpacing) {
          const ax = x + i + offset;
          if (ax > x && ax < x + w) {
            ctx.beginPath(); ctx.moveTo(ax, y + h/2 - 8); ctx.lineTo(ax + 10, y + h/2); ctx.lineTo(ax, y + h/2 + 8); ctx.fill();
          }
        }
      } else if (style.pattern === 'dots') {
        ctx.fillStyle = 'rgba(100,120,160,0.1)';
        for (let i = 0; i < w; i += 25) {
          for (let j = 0; j < h; j += 25) {
            ctx.beginPath(); ctx.arc(x + i, y + j, 2, 0, Math.PI * 2); ctx.fill();
          }
        }
      }
    }

    function drawZoneBorder(zone, style, time) {
      const { x, y, w, h } = zone;
      const pulse = Math.sin(time * 2) * 0.2 + 0.8;
      ctx.save();
      ctx.strokeStyle = style.border;
      ctx.lineWidth = 3;
      ctx.globalAlpha = pulse;
      const r = 15;
      ctx.beginPath();
      ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.stroke();
      ctx.fillStyle = style.border;
      ctx.globalAlpha = 1;
      const cs = 8;
      ctx.fillRect(x - cs/2, y - cs/2, cs, cs);
      ctx.fillRect(x + w - cs/2, y - cs/2, cs, cs);
      ctx.fillRect(x - cs/2, y + h - cs/2, cs, cs);
      ctx.fillRect(x + w - cs/2, y + h - cs/2, cs, cs);
      ctx.restore();
    }

    function drawZoneIcon(zone, style, time) {
      const { x, y, w, h } = zone;
      const iconSize = 24;
      const iconX = x + iconSize, iconY = y + iconSize;
      ctx.save();
      ctx.globalAlpha = 0.7 + Math.sin(time * 3) * 0.2;
      if (zone.type === 'safe') {
        ctx.fillStyle = '#5c5';
        ctx.beginPath();
        ctx.moveTo(iconX, iconY - 10); ctx.lineTo(iconX + 8, iconY - 5);
        ctx.lineTo(iconX + 8, iconY + 5); ctx.lineTo(iconX, iconY + 10);
        ctx.lineTo(iconX - 8, iconY + 5); ctx.lineTo(iconX - 8, iconY - 5);
        ctx.closePath(); ctx.fill();
      } else if (zone.type === 'danger') {
        ctx.fillStyle = '#f55';
        ctx.beginPath(); ctx.arc(iconX, iconY - 3, 6, 0, Math.PI * 2); ctx.fill();
        ctx.fillRect(iconX - 8, iconY + 5, 16, 4);
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(iconX - 3, iconY - 4, 2, 0, Math.PI * 2);
        ctx.arc(iconX + 3, iconY - 4, 2, 0, Math.PI * 2); ctx.fill();
      } else if (zone.type === 'speed') {
        ctx.fillStyle = '#55f';
        ctx.beginPath();
        ctx.moveTo(iconX + 2, iconY - 10); ctx.lineTo(iconX - 6, iconY + 2);
        ctx.lineTo(iconX, iconY + 2); ctx.lineTo(iconX - 4, iconY + 10);
        ctx.lineTo(iconX + 6, iconY - 2); ctx.lineTo(iconX, iconY - 2);
        ctx.closePath(); ctx.fill();
      }
      ctx.restore();
    }

    // === –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –†–∏—Å—É–µ–º –∫—Ä–∞—Å–∏–≤—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã —É—Ä–æ–≤–Ω—è ===
    function drawBoundaries(camX, camY, time) {
      const padding = 100;
      const left = -padding;
      const right = FIELD_SIZE + padding;
      const top = -padding;
      const bottom = FIELD_SIZE + padding;
      
      const myPlayer = getMyPlayer();
      const centerX = myPlayer ? myPlayer.displayX : canvas.width / 2 + camX;
      const centerY = myPlayer ? myPlayer.displayY : canvas.height / 2 + camY;
      
      // –î–∏—Å—Ç–∞–Ω—Ü–∏–∏ –¥–æ –≥—Ä–∞–Ω–∏—Ü
      const distLeft = centerX - 0;
      const distRight = FIELD_SIZE - centerX;
      const distTop = centerY - 0;
      const distBottom = FIELD_SIZE - centerY;
      
      boundaryPulse += 0.05;
      const pulseIntensity = Math.sin(boundaryPulse) * 0.3 + 0.7;
      
      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞—é—â–µ–π –≥—Ä–∞–Ω–∏—Ü—ã
      function drawWarningEdge(x1, y1, x2, y2, distance, isHorizontal) {
        if (distance < BOUNDARY_WARNING) {
          const intensity = 1 - (distance / BOUNDARY_WARNING);
          const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
          
          const alpha = intensity * pulseIntensity * 0.8;
          const width = 3 + intensity * 8;
          
          // –í–Ω–µ—à–Ω–µ–µ —Å–≤–µ—á–µ–Ω–∏–µ (–∫—Ä–∞—Å–Ω–æ–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ)
          ctx.save();
          ctx.strokeStyle = `rgba(255, 80, 80, ${alpha * 0.5})`;
          ctx.lineWidth = width * 3;
          ctx.shadowColor = 'rgba(255, 50, 50, 0.8)';
          ctx.shadowBlur = 20 + intensity * 30;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.restore();
          
          // –û—Å–Ω–æ–≤–Ω–∞—è –ª–∏–Ω–∏—è
          ctx.save();
          ctx.strokeStyle = `rgba(255, 100, 100, ${alpha})`;
          ctx.lineWidth = width;
          ctx.setLineDash([20, 10]);
          ctx.lineDashOffset = -time * 50;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.restore();
          
          // –°—Ç—Ä–µ–ª–∫–∏-—É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–∫ —Ü–µ–Ω—Ç—Ä—É)
          if (intensity > 0.5) {
            ctx.save();
            ctx.fillStyle = `rgba(255, 150, 150, ${alpha})`;
            const arrowCount = Math.floor(Math.abs(isHorizontal ? x2 - x1 : y2 - y1) / 100);
            for (let i = 1; i < arrowCount; i++) {
              const ax = isHorizontal ? x1 + (x2 - x1) * (i / arrowCount) : x1;
              const ay = isHorizontal ? y1 : y1 + (y2 - y1) * (i / arrowCount);
              
              ctx.beginPath();
              if (isHorizontal) {
                if (distance === distLeft) { // –õ–µ–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞ ‚Üí —Å—Ç—Ä–µ–ª–∫–∞ –≤–ø—Ä–∞–≤–æ
                  ctx.moveTo(ax, ay - 8); ctx.lineTo(ax + 12, ay); ctx.lineTo(ax, ay + 8);
                } else { // –ü—Ä–∞–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞ ‚Üí —Å—Ç—Ä–µ–ª–∫–∞ –≤–ª–µ–≤–æ
                  ctx.moveTo(ax, ay - 8); ctx.lineTo(ax - 12, ay); ctx.lineTo(ax, ay + 8);
                }
              } else {
                if (distance === distTop) { // –í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ ‚Üí —Å—Ç—Ä–µ–ª–∫–∞ –≤–Ω–∏–∑
                  ctx.moveTo(ax - 8, ay); ctx.lineTo(ax, ay + 12); ctx.lineTo(ax + 8, ay);
                } else { // –ù–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ ‚Üí —Å—Ç—Ä–µ–ª–∫–∞ –≤–≤–µ—Ä—Ö
                  ctx.moveTo(ax - 8, ay); ctx.lineTo(ax, ay - 12); ctx.lineTo(ax + 8, ay);
                }
              }
              ctx.closePath();
              ctx.fill();
            }
            ctx.restore();
          }
        }
      }
      
      // –†–∏—Å—É–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞—é—â–∏–µ –≥—Ä–∞–Ω–∏—Ü—ã
      drawWarningEdge(left, top, right, top, distTop, true); // –í–µ—Ä—Ö
      drawWarningEdge(left, bottom, right, bottom, distBottom, true); // –ù–∏–∑
      drawWarningEdge(left, top, left, bottom, distLeft, false); // –õ–µ–≤–æ
      drawWarningEdge(right, top, right, bottom, distRight, false); // –ü—Ä–∞–≤–æ
      
      // –û—Å–Ω–æ–≤–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞ –ø–æ–ª—è (–ø–æ—Å—Ç–æ—è–Ω–Ω–∞—è)
      ctx.save();
      ctx.strokeStyle = 'rgba(200, 80, 80, 0.5)';
      ctx.lineWidth = 5;
      ctx.shadowColor = 'rgba(200, 50, 50, 0.6)';
      ctx.shadowBlur = 15;
      ctx.setLineDash([]);
      ctx.strokeRect(0, 0, FIELD_SIZE, FIELD_SIZE);
      ctx.restore();
      
      // –£–≥–ª–æ–≤—ã–µ –º–∞—Ä–∫–µ—Ä—ã –≥—Ä–∞–Ω–∏—Ü
      ctx.save();
      ctx.fillStyle = `rgba(255, 100, 100, ${0.4 + Math.sin(boundaryPulse) * 0.2})`;
      ctx.shadowColor = 'rgba(255, 50, 50, 0.8)';
      ctx.shadowBlur = 20;
      const cornerSize = 20;
      
      // –ß–µ—Ç—ã—Ä–µ —É–≥–ª–∞
      const corners = [[0, 0], [FIELD_SIZE, 0], [0, FIELD_SIZE], [FIELD_SIZE, FIELD_SIZE]];
      for (const [cx, cy] of corners) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∏–¥–µ–Ω –ª–∏ —É–≥–æ–ª
        const distToCorner = Math.hypot(cx - centerX, cy - centerY);
        if (distToCorner < BOUNDARY_WARNING + 200) {
          ctx.beginPath();
          ctx.arc(cx, cy, cornerSize, 0, Math.PI * 2);
          ctx.fill();
          
          // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫—Ä—É–≥
          ctx.fillStyle = 'rgba(255, 200, 200, 0.8)';
          ctx.beginPath();
          ctx.arc(cx, cy, cornerSize * 0.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = `rgba(255, 100, 100, ${0.4 + Math.sin(boundaryPulse) * 0.2})`;
        }
      }
      ctx.restore();
      
      // "–ó–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏" ‚Äî –≤–∏–Ω—å–µ—Ç–∫–∞
      const vignetteGradient = ctx.createRadialGradient(
        centerX - camX, centerY - camY, Math.min(canvas.width, canvas.height) * 0.3,
        centerX - camX, centerY - camY, Math.max(canvas.width, canvas.height) * 0.8
      );
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Å–∫–æ–ª—å–∫–æ –±–ª–∏–∑–∫–æ –∏–≥—Ä–æ–∫ –∫ –≥—Ä–∞–Ω–∏—Ü–∞–º
      const minBoundaryDist = Math.min(distLeft, distRight, distTop, distBottom);
      if (minBoundaryDist < BOUNDARY_WARNING) {
        const vignetteIntensity = (1 - minBoundaryDist / BOUNDARY_WARNING) * 0.7;
        vignetteGradient.addColorStop(0, 'rgba(180, 50, 50, 0)');
        vignetteGradient.addColorStop(0.5, `rgba(180, 50, 50, ${vignetteIntensity * 0.3})`);
        vignetteGradient.addColorStop(1, `rgba(180, 50, 50, ${vignetteIntensity})`);
      } else {
        vignetteGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
        vignetteGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.1)');
        vignetteGradient.addColorStop(1, 'rgba(0, 0, 0, 0.4)');
      }
      
      ctx.fillStyle = vignetteGradient;
      ctx.fillRect(camX, camY, canvas.width, canvas.height);
    }

    function draw() {
      const time = Date.now() * 0.001;
      
      // === –§–û–ù: –≥—Ä–∞–¥–∏–µ–Ω—Ç + –∑–≤—ë–∑–¥—ã ===
      const bgGradient = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, 0,
        canvas.width/2, canvas.height/2, canvas.width
      );
      
      if (globalEvent === 'darkness') {
        bgGradient.addColorStop(0, '#080815');
        bgGradient.addColorStop(0.5, '#04040a');
        bgGradient.addColorStop(1, '#020205');
      } else if (globalEvent === 'heatwave') {
        bgGradient.addColorStop(0, '#1a0a0a');
        bgGradient.addColorStop(0.5, '#0f0505');
        bgGradient.addColorStop(1, '#050202');
      } else {
        bgGradient.addColorStop(0, '#0d1020');
        bgGradient.addColorStop(0.5, '#080a15');
        bgGradient.addColorStop(1, '#05050a');
      }
      
      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // –ó–≤—ë–∑–¥—ã (–º–µ—Ä—Ü–∞—é—â–∏–µ)
      ctx.save();
      for (const star of bgStars) {
        const twinkle = Math.sin(time * 2 + star.twinkle) * 0.3 + 0.7;
        ctx.fillStyle = `rgba(180,200,255,${star.alpha * twinkle})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();

      const myPlayer = getMyPlayer();
      let camX = 0, camY = 0;
      
      if (myPlayer) {
        camX = myPlayer.x - canvas.width / 2;
        camY = myPlayer.y - canvas.height / 2;
        myPlayer.displayX = lerp(myPlayer.displayX, myPlayer.x, 0.15);
        myPlayer.displayY = lerp(myPlayer.displayY, myPlayer.y, 0.15);
      }

      ctx.save();
      
      if (screenShake > 0) {
        ctx.translate((Math.random() - 0.5) * screenShake, (Math.random() - 0.5) * screenShake);
      }
      ctx.translate(-camX, -camY);

      // === –û–¢–†–ò–°–û–í–ö–ê –ó–û–ù ===
      for (const zone of zones) {
        const style = ZONE_STYLES[zone.type];
        const { x, y, w, h } = zone;
        ctx.fillStyle = style.bg;
        ctx.fillRect(x, y, w, h);
        if (style.glow) {
          ctx.shadowColor = style.glow;
          ctx.shadowBlur = 30;
          ctx.fillStyle = style.glow;
          ctx.fillRect(x, y, w, h);
          ctx.shadowBlur = 0;
        }
        drawZonePattern(zone, style, time);
        drawZoneBorder(zone, style, time);
        drawZoneIcon(zone, style, time);
      }

      // === –°–ï–¢–ö–ê ===
      const gridSize = 80;
      ctx.strokeStyle = 'rgba(90,110,160,0.2)';
      ctx.lineWidth = 1;
      const startX = Math.floor(camX / gridSize) * gridSize - gridSize;
      const startY = Math.floor(camY / gridSize) * gridSize - gridSize;
      const endX = startX + canvas.width + gridSize * 2;
      const endY = startY + canvas.height + gridSize * 2;
      
      for (let x = startX; x < endX; x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, endY); ctx.stroke();
      }
      for (let y = startY; y < endY; y += gridSize) {
        ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(endX, y); ctx.stroke();
      }
      
      // –û—Å–Ω–æ–≤–Ω—ã–µ –ª–∏–Ω–∏–∏ —Å–µ—Ç–∫–∏ (–∫–∞–∂–¥—ã–µ 400px)
      ctx.strokeStyle = 'rgba(120,140,200,0.35)';
      ctx.lineWidth = 2;
      const majorGrid = 400;
      for (let x = 0; x <= FIELD_SIZE; x += majorGrid) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, FIELD_SIZE); ctx.stroke();
      }
      for (let y = 0; y <= FIELD_SIZE; y += majorGrid) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(FIELD_SIZE, y); ctx.stroke();
      }

      ctx.shadowBlur = 20;
      
      const hosts = [], parasites = [];
      for (const [id, player] of players) {
        if (player.hostId !== null) parasites.push(player);
        else hosts.push(player);
      }

      // === –•–û–°–¢–´ ===
      for (const player of hosts) {
        const isMine = player.id === myId;
        const displayX = isMine ? player.displayX : player.x;
        const displayY = isMine ? player.displayY : player.y;
        
        player.pulse += 0.05;
        const pulseSize = Math.sin(player.pulse) * 1.5;
        const speed = Math.hypot(player.vx, player.vy);
        const stretch = Math.min(speed * 0.02, 0.3);
        const angle = Math.atan2(player.vy, player.vx);

        ctx.save();
        ctx.translate(displayX, displayY);
        ctx.rotate(angle);
        ctx.scale(1 + stretch, 1 - stretch * 0.5);
        ctx.rotate(-angle);

        if (player.heat > 50) {
          ctx.shadowColor = `hsl(${60 - player.heat * 0.6}, 100%, 50%)`;
          ctx.shadowBlur = 20 + player.heat * 0.4;
        } else {
          ctx.shadowColor = isMine ? '#48f' : '#f64';
          ctx.shadowBlur = 25 + pulseSize * 5;
        }

        if (player.stunned > 0) {
          ctx.shadowColor = '#888';
          ctx.shadowBlur = 30;
        }

        ctx.beginPath();
        ctx.arc(0, 0, player.radius + pulseSize, 0, Math.PI * 2);
        
        if (player.stunned > 0) ctx.fillStyle = '#888';
        else if (isMine) ctx.fillStyle = `hsl(${210 + Math.sin(time)*15}, 85%, 60%)`;
        else ctx.fillStyle = `hsl(${15 + Math.sin(time)*15}, 85%, 60%)`;
        ctx.fill();

        ctx.shadowBlur = 0;
        const grad = ctx.createRadialGradient(-3, -3, 0, 0, 0, player.radius);
        grad.addColorStop(0, 'rgba(255,255,255,0.5)');
        grad.addColorStop(0.6, 'rgba(255,255,255,0.15)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.ellipse(-4, -2, 4, 5, 0, 0, Math.PI * 2);
        ctx.ellipse(4, -2, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#000';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(-3, -2, 2.5, 0, Math.PI * 2);
        ctx.arc(5, -2, 2.5, 0, Math.PI * 2);
        ctx.fill();

        if (player.combo >= 2) {
          ctx.strokeStyle = `hsl(${50 + player.combo * 10}, 100%, 50%)`;
          ctx.lineWidth = 3;
          ctx.shadowColor = ctx.strokeStyle;
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(0, 0, player.radius + 10 + player.combo * 2, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.restore();

        if (isMine) {
          ctx.strokeStyle = 'rgba(100,255,150,0.9)';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#4f8';
          ctx.shadowBlur = 20;
          ctx.beginPath();
          ctx.arc(displayX, displayY, player.radius + 10, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      // === –ü–ê–†–ê–ó–ò–¢–´ ===
      for (const parasite of parasites) {
        const host = players.get(parasite.hostId);
        if (!host) continue;
        const isMine = parasite.id === myId;
        const offsetX = (parasite.id % 3 - 1) * 16;
        const offsetY = (Math.floor(parasite.id / 3) % 3 - 1) * 16;
        const px = host.x + offsetX;
        const py = host.y + offsetY;

        ctx.shadowColor = isMine ? '#4f4' : '#f44';
        ctx.shadowBlur = 18;

        ctx.beginPath();
        ctx.arc(px, py, PLAYER_RADIUS * 0.6, 0, Math.PI * 2);
        ctx.fillStyle = isMine 
          ? `hsl(${140 + Math.sin(time)*10}, 90%, 55%)` 
          : `hsl(${350 + Math.sin(time)*10}, 90%, 55%)`;
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(px - 3, py - 1, 3, 0, Math.PI * 2);
        ctx.arc(px + 3, py - 1, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#ff0';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(px - 2, py - 1, 1.5, 0, Math.PI * 2);
        ctx.arc(px + 4, py - 1, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
      
      // === –ì–†–ê–ù–ò–¶–´ –£–†–û–í–ù–Ø (–ø–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ) ===
      drawBoundaries(camX, camY, time);
      
      drawParticles();
      updateParticles();

      if (myPlayer) {
        heatBarEl.style.display = myPlayer.hostId === null ? 'block' : 'none';
        heatFillEl.style.width = myPlayer.heat + '%';
        heatValueEl.textContent = Math.round(myPlayer.heat) + '%';
        heatFillEl.style.boxShadow = myPlayer.heat > 80 ? '0 0 30px rgba(255,50,50,0.8)' : 
                                     myPlayer.heat > 50 ? '0 0 20px rgba(255,200,50,0.6)' : 'none';
        comboDisplayEl.textContent = `üî• x${myPlayer.combo} COMBO!`;
        comboDisplayEl.style.display = myPlayer.combo >= 2 ? 'block' : 'none';
        if (myPlayer.combo >= 2) {
          comboDisplayEl.style.color = `hsl(${50 + myPlayer.combo * 15}, 100%, 50%)`;
        }
      }

      updateExitTimer();
      updatePing();
      requestAnimationFrame(draw);
    }

    function updateExitTimer() {
      const myPlayer = getMyPlayer();
      if (myPlayer && myPlayer.hostId !== null && myPlayer.infectedAt) {
        exitTimerEl.style.display = 'block';
        const elapsed = Date.now() - myPlayer.infectedAt;
        const remaining = Math.max(0, (INFECT_DURATION - elapsed) / 1000);
        timerValueEl.textContent = remaining.toFixed(1);
        exitTimerEl.style.color = remaining < 2 ? '#4f4' : '#ff6b6b';
      } else {
        exitTimerEl.style.display = 'none';
      }
    }

    function updatePing() {
      if (lastServerTime > 0) {
        const ping = Date.now() - lastServerTime;
        pingEl.textContent = ping;
        pingEl.style.color = ping < 50 ? '#4f4' : ping < 100 ? '#ff4' : '#f44';
      }
    }

    setInterval(sendMovement, 1000 / 30);
    draw();

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initStars();
    });

    connect();
  </script>
</body>
</html>
