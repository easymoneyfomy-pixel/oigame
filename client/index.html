<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parasite Arena</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #0a0a14; }
    canvas { display: block; }
    
    #hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      font-family: 'Segoe UI', 'Roboto', sans-serif;
      font-size: 14px;
      background: linear-gradient(135deg, rgba(15,15,30,0.92), rgba(8,8,20,0.96));
      padding: 18px 22px;
      border-radius: 14px;
      z-index: 100;
      user-select: none;
      border: 1px solid rgba(100,140,220,0.25);
      box-shadow: 0 10px 40px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.08);
      backdrop-filter: blur(12px);
      min-width: 200px;
    }
    #hud h1 {
      font-size: 18px;
      background: linear-gradient(90deg, #7af, #5f9);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 12px;
      text-shadow: 0 0 25px rgba(100,180,255,0.4);
    }
    #hud .control { margin: 7px 0; color: #a8c; }
    #hud .control kbd {
      background: rgba(100,140,220,0.2);
      padding: 2px 8px;
      border-radius: 5px;
      border: 1px solid rgba(100,140,220,0.35);
      font-family: monospace;
      color: #8cf;
    }
    #hud .divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(100,140,220,0.35), transparent);
      margin: 12px 0;
    }
    #hud .stat { display: flex; justify-content: space-between; margin: 6px 0; }
    #hud .stat-label { color: #89a; }
    #hud .stat-value { font-weight: bold; }
    #hud .stat-value.good { color: #5f8; }
    #hud .stat-value.warn { color: #fa6; }
    #hud .stat-value.bad { color: #f66; }
    
    #statusBadge {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-family: 'Segoe UI', 'Roboto', sans-serif;
      font-size: 13px;
      font-weight: bold;
      padding: 10px 18px;
      border-radius: 25px;
      z-index: 100;
      user-select: none;
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      transition: all 0.3s ease;
    }
    #statusBadge.free {
      background: linear-gradient(135deg, #3a6, #285);
      border: 1px solid rgba(80,200,120,0.4);
    }
    #statusBadge.parasite {
      background: linear-gradient(135deg, #d44, #a33);
      border: 1px solid rgba(220,80,80,0.4);
    }
    #statusBadge.host {
      background: linear-gradient(135deg, #64a, #539);
      border: 1px solid rgba(140,100,220,0.4);
    }
    
    #exitTimer {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ff7b7b;
      font-family: 'Segoe UI', 'Roboto', sans-serif;
      font-size: 28px;
      font-weight: bold;
      text-shadow: 0 0 25px rgba(255,120,120,0.9), 0 0 50px rgba(255,120,120,0.5);
      display: none;
      z-index: 100;
      pointer-events: none;
      animation: timerPulse 0.4s ease-in-out infinite alternate;
      background: rgba(30,10,10,0.85);
      padding: 15px 30px;
      border-radius: 12px;
      border: 1px solid rgba(255,100,100,0.3);
    }
    @keyframes timerPulse {
      from { opacity: 0.75; transform: translate(-50%, -50%) scale(1); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1.03); }
    }
    
    #infectEffect {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 42px;
      font-weight: bold;
      color: #ff5566;
      text-shadow: 0 0 35px rgba(255,80,100,0.9);
      pointer-events: none;
      z-index: 200;
      animation: infectAnim 0.7s ease-out forwards;
      display: none;
      background: rgba(40,10,15,0.9);
      padding: 20px 40px;
      border-radius: 15px;
      border: 2px solid rgba(255,80,100,0.5);
    }
    @keyframes infectAnim {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.6) rotate(-5deg); }
      40% { opacity: 1; transform: translate(-50%, -50%) scale(1.15) rotate(0deg); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1) rotate(5deg); }
    }
    
    #playerJoinEffect {
      position: fixed;
      top: 15%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      color: #7bf;
      text-shadow: 0 0 18px rgba(100,180,255,0.85);
      pointer-events: none;
      z-index: 200;
      animation: joinFade 1.4s ease-out forwards;
      display: none;
      background: rgba(10,20,35,0.85);
      padding: 10px 25px;
      border-radius: 20px;
      border: 1px solid rgba(100,180,255,0.35);
    }
    @keyframes joinFade {
      0% { opacity: 0; transform: translateX(-50%) translateY(-15px); }
      15% { opacity: 1; transform: translateX(-50%) translateY(0); }
      75% { opacity: 1; transform: translateX(-50%) translateY(0); }
      100% { opacity: 0; transform: translateX(-50%) translateY(-15px); }
    }
    
    #rageEffect {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
      background: radial-gradient(ellipse at center, transparent 0%, transparent 60%, rgba(255,100,100,0.15) 100%);
      display: none;
      animation: ragePulse 0.8s ease-in-out infinite;
    }
    @keyframes ragePulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    #cooldownIndicator {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: 8px;
      background: rgba(30,30,50,0.8);
      border-radius: 6px;
      overflow: hidden;
      z-index: 100;
      border: 1px solid rgba(100,140,220,0.3);
      display: none;
    }
    #cooldownBar {
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, #f66, #fa6);
      transition: width 0.1s linear;
    }
    
    #connectionStatus {
      position: fixed;
      top: 20px;
      right: 20px;
      font-family: 'Segoe UI', 'Roboto', sans-serif;
      font-size: 12px;
      color: #688;
      background: rgba(0,0,0,0.5);
      padding: 8px 14px;
      border-radius: 8px;
      z-index: 100;
    }
    #connectionStatus.connected { color: #5b5; }
    #connectionStatus.disconnected { color: #f66; }
    #connectionStatus.reconnecting { color: #fa6; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  
  <div id="hud">
    <h1>ü¶† PARASITE ARENA</h1>
    <div class="control"><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> ‚Äî Move</div>
    <div class="control"><kbd>SPACE</kbd> ‚Äî Infect</div>
    <div class="divider"></div>
    <div class="stat"><span class="stat-label">Players</span><span id="playerCount" class="stat-value good">0</span></div>
    <div class="stat"><span class="stat-label">Ping</span><span id="ping" class="stat-value">--</span></div>
    <div class="stat"><span class="stat-label">Status</span><span id="myStatus" class="stat-value">FREE</span></div>
  </div>
  
  <div id="statusBadge" class="free">FREE</div>
  <div id="exitTimer">‚è± FREE IN <span id="timerValue">5.0</span>s</div>
  <div id="infectEffect">üíâ INFECTED!</div>
  <div id="playerJoinEffect">‚ûï Player joined!</div>
  <div id="rageEffect"></div>
  <div id="cooldownIndicator"><div id="cooldownBar"></div></div>
  <div id="connectionStatus" class="disconnected">Disconnected</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const playerCountEl = document.getElementById('playerCount');
    const pingEl = document.getElementById('ping');
    const myStatusEl = document.getElementById('myStatus');
    const statusBadgeEl = document.getElementById('statusBadge');
    const exitTimerEl = document.getElementById('exitTimer');
    const timerValueEl = document.getElementById('timerValue');
    const connectionStatusEl = document.getElementById('connectionStatus');
    const infectEffectEl = document.getElementById('infectEffect');
    const playerJoinEffectEl = document.getElementById('playerJoinEffect');
    const rageEffectEl = document.getElementById('rageEffect');
    const cooldownIndicatorEl = document.getElementById('cooldownIndicator');
    const cooldownBarEl = document.getElementById('cooldownBar');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const WS_URL = `wss://${window.location.host}`;
    
    let CONFIG = {
      playerRadius: 14,
      parasiteRadius: 7,
      infectDuration: 5000,
      infectCooldown: 1500,
      maxParasites: 4
    };

    let ws = null;
    let players = new Map();
    let myId = null;
    let lastServerTime = 0;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    let particles = [];
    let floatingTexts = [];
    let infectionAnimations = new Map();
    let lastInfectTime = 0;

    const keysDown = {};
    let cameraX = 0, cameraY = 0;
    let targetCameraX = 0, targetCameraY = 0;

    document.addEventListener('keydown', (e) => {
      if (['KeyW','KeyA','KeyS','KeyD','Space'].includes(e.code)) e.preventDefault();
      keysDown[e.code] = true;
      if (e.code === 'Space') tryInfect();
    });

    document.addEventListener('keyup', (e) => {
      keysDown[e.code] = false;
    });

    function connect() {
      if (ws) ws.close();
      connectionStatusEl.textContent = 'Connecting...';
      connectionStatusEl.className = 'reconnecting';
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        connectionStatusEl.textContent = 'Connected';
        connectionStatusEl.className = 'connected';
        reconnectAttempts = 0;
        createParticles(canvas.width/2, canvas.height/2, 25, '#5a8');
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'welcome') {
            myId = data.playerId;
            if (data.gameConfig) CONFIG = { ...CONFIG, ...data.gameConfig };
          } else if (data.type === 'state') {
            lastServerTime = data.t;
            updatePlayers(data.p);
          } else if (data.type === 'event') {
            handleEvent(data.event);
          }
        } catch (e) {}
      };

      ws.onclose = () => {
        connectionStatusEl.textContent = 'Disconnected';
        connectionStatusEl.className = 'disconnected';
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          reconnectAttempts++;
          connectionStatusEl.textContent = `Reconnecting (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`;
          setTimeout(connect, 2000);
        }
      };

      ws.onerror = () => {
        connectionStatusEl.textContent = 'Error';
        connectionStatusEl.className = 'disconnected';
      };
    }

    function handleEvent(event) {
      if (event.type === 'infect') {
        const screenX = event.x - cameraX;
        const screenY = event.y - cameraY;
        createParticles(screenX, screenY, 35, '#f55');
        createParticles(screenX, screenY, 18, '#ff8');
        
        infectionAnimations.set(event.target, {
          scale: 0.3,
          alpha: 1,
          startTime: Date.now()
        });

        if (event.target === myId) {
          showInfectEffect();
        }
      }
      else if (event.type === 'parasiteExit') {
        const screenX = event.x - cameraX;
        const screenY = event.y - cameraY;
        createParticles(screenX, screenY, 20, '#5f6');
        addFloatingText(screenX, screenY, 'FREE!', '#5f6');
      }
      else if (event.type === 'playerJoin') {
        showPlayerJoinEffect();
      }
      else if (event.type === 'playerLeave') {
        addFloatingText(canvas.width/2, 100, 'Player left', '#889');
      }
    }

    function updatePlayers(playerData) {
      const now = Date.now();
      for (const p of playerData) {
        const [id, x, y, hostId, infectedAt, rageMode, stunned] = p;
        const existing = players.get(id);
        
        if (existing) {
          existing.x = x;
          existing.y = y;
          existing.hostId = hostId;
          existing.infectedAt = infectedAt;
          existing.rageMode = rageMode === 1;
          existing.stunned = stunned === 1;
        } else {
          players.set(id, {
            id, x, y, hostId, infectedAt,
            displayX: x, displayY: y,
            prevDisplayX: x, prevDisplayY: y,
            rageMode: rageMode === 1,
            stunned: stunned === 1,
            pulse: Math.random() * Math.PI * 2,
            fadeIn: 0
          });
        }
      }
      
      for (const [id, player] of players) {
        if (!playerData.find(p => p[0] === id)) {
          players.delete(id);
        }
      }
      
      playerCountEl.textContent = players.size;
    }

    function getMyPlayer() {
      return players.get(myId);
    }

    function tryInfect() {
      const myPlayer = getMyPlayer();
      if (!myPlayer || myPlayer.hostId !== null) return;
      
      const now = Date.now();
      if (now - lastInfectTime < CONFIG.infectCooldown) return;

      let closest = null, closestDist = Infinity;
      for (const [id, p] of players) {
        if (id === myPlayer.id || p.hostId !== null) continue;
        const dist = Math.hypot(p.displayX - myPlayer.displayX, p.displayY - myPlayer.displayY);
        if (dist < closestDist) { closestDist = dist; closest = p; }
      }

      const infectRange = CONFIG.playerRadius * 3.5;
      if (closest && closestDist < infectRange) {
        ws.send(JSON.stringify({ type: 'infect', targetId: closest.id }));
        lastInfectTime = now;
        showCooldown();
      }
    }

    function showCooldown() {
      cooldownIndicatorEl.style.display = 'block';
      cooldownBarEl.style.width = '100%';
      
      const startTime = Date.now();
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const remaining = Math.max(0, CONFIG.infectCooldown - elapsed);
        cooldownBarEl.style.width = (remaining / CONFIG.infectCooldown * 100) + '%';
        
        if (remaining > 0) requestAnimationFrame(animate);
        else cooldownIndicatorEl.style.display = 'none';
      };
      animate();
    }

    function showInfectEffect() {
      infectEffectEl.style.display = 'block';
      infectEffectEl.style.animation = 'none';
      infectEffectEl.offsetHeight;
      infectEffectEl.style.animation = 'infectAnim 0.7s ease-out forwards';
      setTimeout(() => { infectEffectEl.style.display = 'none'; }, 700);
    }

    function showPlayerJoinEffect() {
      playerJoinEffectEl.style.display = 'block';
      playerJoinEffectEl.style.animation = 'none';
      playerJoinEffectEl.offsetHeight;
      playerJoinEffectEl.style.animation = 'joinFade 1.4s ease-out forwards';
      setTimeout(() => { playerJoinEffectEl.style.display = 'none'; }, 1400);
    }

    function addFloatingText(x, y, text, color) {
      floatingTexts.push({ x, y, text, color, life: 1, vy: -0.8, size: 15 });
    }

    function sendMovement() {
      const myPlayer = getMyPlayer();
      if (!myPlayer || myPlayer.hostId !== null) return;

      let dx = 0, dy = 0;
      if (keysDown['KeyW']) dy = -1;
      if (keysDown['KeyS']) dy = 1;
      if (keysDown['KeyA']) dx = -1;
      if (keysDown['KeyD']) dx = 1;

      if (dx !== 0 || dy !== 0) {
        ws.send(JSON.stringify({ type: 'move', dx, dy }));
      }
    }

    function createParticles(x, y, count, color) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 5 + 2;
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1,
          decay: Math.random() * 0.025 + 0.012,
          color: color,
          size: Math.random() * 5 + 2
        });
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life -= p.decay;
        if (p.life <= 0) particles.splice(i, 1);
      }

      for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i];
        t.y += t.vy;
        t.life -= 0.018;
        if (t.life <= 0) floatingTexts.splice(i, 1);
      }
      
      for (const [id, anim] of infectionAnimations) {
        const elapsed = Date.now() - anim.startTime;
        anim.scale = 0.3 + (elapsed / 400) * 0.7;
        anim.alpha = Math.max(0, 1 - elapsed / 400);
        if (elapsed > 400) infectionAnimations.delete(id);
      }
    }

    function drawParticles() {
      for (const p of particles) {
        ctx.save();
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      for (const t of floatingTexts) {
        ctx.save();
        ctx.globalAlpha = t.life;
        ctx.fillStyle = t.color;
        ctx.font = `bold ${t.size}px "Segoe UI"`;
        ctx.textAlign = 'center';
        ctx.shadowColor = t.color;
        ctx.shadowBlur = 12;
        ctx.fillText(t.text, t.x, t.y);
        ctx.restore();
      }
    }

    function lerp(a, b, t) { return a + (b - a) * t; }
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function draw() {
      const gradient = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, 0,
        canvas.width/2, canvas.height/2, canvas.width * 0.8
      );
      gradient.addColorStop(0, '#0e0e1e');
      gradient.addColorStop(0.6, '#0a0a14');
      gradient.addColorStop(1, '#05050a');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const myPlayer = getMyPlayer();
      
      if (myPlayer) {
        targetCameraX = myPlayer.displayX - canvas.width / 2;
        targetCameraY = myPlayer.displayY - canvas.height / 2;
        cameraX = lerp(cameraX, targetCameraX, 0.08);
        cameraY = lerp(cameraY, targetCameraY, 0.08);
        
        myPlayer.displayX = lerp(myPlayer.displayX, myPlayer.x, 0.2);
        myPlayer.displayY = lerp(myPlayer.displayY, myPlayer.y, 0.2);
      }

      ctx.save();
      ctx.translate(-cameraX, -cameraY);

      const gridSize = 50;
      ctx.strokeStyle = 'rgba(50,70,100,0.25)';
      ctx.lineWidth = 1;
      const startX = Math.floor(cameraX / gridSize) * gridSize - gridSize;
      const startY = Math.floor(cameraY / gridSize) * gridSize - gridSize;
      
      for (let x = startX; x < cameraX + canvas.width + gridSize; x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, startY + canvas.height + gridSize * 2); ctx.stroke();
      }
      for (let y = startY; y < cameraY + canvas.height + gridSize; y += gridSize) {
        ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(startX + canvas.width + gridSize * 2, y); ctx.stroke();
      }

      const hosts = [], parasites = [];
      for (const [id, player] of players) {
        if (player.hostId !== null) parasites.push(player);
        else hosts.push(player);
      }

      for (const player of hosts) {
        const isMine = player.id === myId;
        player.pulse += 0.04;
        const pulseSize = Math.sin(player.pulse) * 1.5;
        const baseRadius = player.radius || CONFIG.playerRadius;

        const displayX = isMine ? player.displayX : player.x;
        const displayY = isMine ? player.displayY : player.y;

        if (!isMine) {
          player.displayX = lerp(player.displayX, player.x, 0.15);
          player.displayY = lerp(player.displayY, player.y, 0.15);
        }

        if (player.fadeIn < 1) player.fadeIn += 0.05;
        
        ctx.save();
        ctx.globalAlpha = player.fadeIn;
        
        const glowColor = isMine ? '#4a8' : player.rageMode ? '#f85' : '#f75';
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = player.rageMode ? 35 : 22 + pulseSize * 4;

        ctx.beginPath();
        ctx.arc(displayX, displayY, baseRadius + pulseSize, 0, Math.PI * 2);
        
        const hue = isMine ? (150 + Math.sin(Date.now() * 0.003) * 15) : (25 + Math.sin(Date.now() * 0.003) * 12);
        const sat = isMine ? 70 : 75;
        const light = isMine ? 50 : 55;
        ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
        ctx.fill();

        ctx.shadowBlur = 0;
        const grad = ctx.createRadialGradient(displayX - 4, displayY - 4, 0, displayX, displayY, baseRadius);
        grad.addColorStop(0, 'rgba(255,255,255,0.35)');
        grad.addColorStop(0.5, 'rgba(255,255,255,0.08)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.fill();

        if (player.rageMode) {
          ctx.strokeStyle = 'rgba(255,150,80,0.7)';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#f84';
          ctx.shadowBlur = 20;
          ctx.beginPath();
          ctx.arc(displayX, displayY, baseRadius + 10, 0, Math.PI * 2);
          ctx.stroke();
        }

        if (player.stunned) {
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.font = 'bold 14px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('üí´', displayX, displayY - baseRadius - 8);
        }

        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.ellipse(displayX - 5, displayY - 2, 4.5, 5.5, 0, 0, Math.PI * 2);
        ctx.ellipse(displayX + 5, displayY - 2, 4.5, 5.5, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#0a0a14';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(displayX - 3.5, displayY - 2, 2.2, 0, Math.PI * 2);
        ctx.arc(displayX + 5.5, displayY - 2, 2.2, 0, Math.PI * 2);
        ctx.fill();

        if (isMine) {
          ctx.strokeStyle = 'rgba(80,220,130,0.85)';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#5e8';
          ctx.shadowBlur = 18;
          ctx.beginPath();
          ctx.arc(displayX, displayY, baseRadius + 9, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        ctx.restore();
      }

      for (const parasite of parasites) {
        const host = players.get(parasite.hostId);
        if (!host) continue;

        const isMine = parasite.id === myId;
        const parasiteRadius = CONFIG.parasiteRadius || 7;
        
        const parasiteCount = [...players.values()].filter(p => p.hostId === host.id).length;
        const angleStep = (Math.PI * 2) / Math.max(parasiteCount, 1);
        const parasiteIndex = [...players.values()].filter(p => p.hostId === host.id).indexOf(parasite);
        const orbitAngle = parasiteIndex * angleStep + Date.now() * 0.002;
        const orbitRadius = CONFIG.playerRadius * 0.7;
        
        const px = host.displayX + Math.cos(orbitAngle) * orbitRadius;
        const py = host.displayY + Math.sin(orbitAngle) * orbitRadius;

        ctx.shadowColor = isMine ? '#5f7' : '#f56';
        ctx.shadowBlur = isMine ? 18 : 14;

        ctx.beginPath();
        ctx.arc(px, py, parasiteRadius, 0, Math.PI * 2);
        const hue = isMine ? (145 + Math.sin(Date.now() * 0.004) * 10) : (355 + Math.sin(Date.now() * 0.004) * 8);
        ctx.fillStyle = `hsl(${hue}, 85%, 55%)`;
        ctx.fill();

        ctx.strokeStyle = isMine ? 'rgba(150,255,180,0.8)' : 'rgba(255,150,160,0.7)';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#ff0';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(px - 2.5, py - 1, 2, 0, Math.PI * 2);
        ctx.arc(px + 2.5, py - 1, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#ff0';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(px - 1.5, py - 1, 1, 0, Math.PI * 2);
        ctx.arc(px + 3, py - 1, 1, 0, Math.PI * 2);
        ctx.fill();
      }

      for (const [id, anim] of infectionAnimations) {
        const player = players.get(id);
        if (!player) continue;
        
        ctx.save();
        ctx.globalAlpha = anim.alpha;
        ctx.scale(anim.scale, anim.scale);
        ctx.strokeStyle = 'rgba(255,80,100,0.8)';
        ctx.lineWidth = 4;
        ctx.shadowColor = '#f55';
        ctx.shadowBlur = 25;
        ctx.beginPath();
        ctx.arc(player.x / anim.scale, player.y / anim.scale, CONFIG.playerRadius * 1.5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      ctx.restore();

      drawParticles();
      updateUI();
      updateParticles();

      requestAnimationFrame(draw);
    }

    function updateUI() {
      const myPlayer = getMyPlayer();
      
      if (myPlayer) {
        let status = 'FREE';
        let statusClass = 'free';
        
        if (myPlayer.hostId !== null) {
          status = 'PARASITE';
          statusClass = 'parasite';
          
          if (myPlayer.infectedAt) {
            exitTimerEl.style.display = 'block';
            const elapsed = Date.now() - myPlayer.infectedAt;
            const remaining = Math.max(0, (CONFIG.infectDuration - elapsed) / 1000);
            timerValueEl.textContent = remaining.toFixed(1);
            
            if (remaining < 2) {
              exitTimerEl.style.color = '#5f7';
              exitTimerEl.innerHTML = '‚è± FREE NOW!';
            } else {
              exitTimerEl.style.color = '#ff7b7b';
              exitTimerEl.innerHTML = '‚è± FREE IN <span id="timerValue">' + remaining.toFixed(1) + '</span>s';
            }
          }
        } else {
          exitTimerEl.style.display = 'none';
          
          if (myPlayer.rageMode) {
            status = 'RAGE!';
            statusClass = 'host';
            rageEffectEl.style.display = 'block';
          } else {
            rageEffectEl.style.display = 'none';
          }
        }
        
        myStatusEl.textContent = status;
        myStatusEl.className = 'stat-value ' + (statusClass === 'free' ? 'good' : statusClass === 'parasite' ? 'bad' : 'warn');
        statusBadgeEl.textContent = status;
        statusBadgeEl.className = statusClass;
      } else {
        exitTimerEl.style.display = 'none';
        rageEffectEl.style.display = 'none';
      }

      if (lastServerTime > 0) {
        const ping = Date.now() - lastServerTime;
        pingEl.textContent = ping;
        pingEl.className = 'stat-value ' + (ping < 50 ? 'good' : ping < 100 ? 'warn' : 'bad');
      }
    }

    setInterval(sendMovement, 1000 / 30);
    draw();

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    connect();
  </script>
</body>
</html>
